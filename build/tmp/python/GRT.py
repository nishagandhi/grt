# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GRT')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GRT')
    _GRT = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GRT', [dirname(__file__)])
        except ImportError:
            import _GRT
            return _GRT
        try:
            _mod = imp.load_module('_GRT', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GRT = swig_import_helper()
    del swig_import_helper
else:
    import _GRT
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GRT.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _GRT.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _GRT.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _GRT.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _GRT.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _GRT.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _GRT.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _GRT.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _GRT.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _GRT.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _GRT.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _GRT.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _GRT.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _GRT.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _GRT.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _GRT.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _GRT.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GRT.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class IntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _GRT.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _GRT.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _GRT.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _GRT.IntVector___len__(self)

    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        return _GRT.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _GRT.IntVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        return _GRT.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _GRT.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _GRT.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _GRT.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _GRT.IntVector_pop(self)

    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _GRT.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _GRT.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _GRT.IntVector_size(self)

    def swap(self, v: 'IntVector') -> "void":
        return _GRT.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _GRT.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _GRT.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _GRT.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _GRT.IntVector_rend(self)

    def clear(self) -> "void":
        return _GRT.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _GRT.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _GRT.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _GRT.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _GRT.new_IntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _GRT.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _GRT.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _GRT.IntVector_back(self)

    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        return _GRT.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _GRT.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _GRT.IntVector_insert(self, *args)

    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        return _GRT.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _GRT.IntVector_capacity(self)
    __swig_destroy__ = _GRT.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _GRT.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _GRT.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _GRT.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _GRT.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _GRT.DoubleVector___len__(self)

    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        return _GRT.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _GRT.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        return _GRT.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _GRT.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _GRT.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _GRT.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _GRT.DoubleVector_pop(self)

    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _GRT.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _GRT.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _GRT.DoubleVector_size(self)

    def swap(self, v: 'DoubleVector') -> "void":
        return _GRT.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _GRT.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _GRT.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _GRT.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _GRT.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _GRT.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _GRT.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _GRT.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _GRT.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _GRT.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _GRT.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _GRT.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _GRT.DoubleVector_back(self)

    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        return _GRT.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _GRT.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _GRT.DoubleVector_insert(self, *args)

    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        return _GRT.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _GRT.DoubleVector_capacity(self)
    __swig_destroy__ = _GRT.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _GRT.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class FloatVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _GRT.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _GRT.FloatVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _GRT.FloatVector___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _GRT.FloatVector___len__(self)

    def __getslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "std::vector< float,std::allocator< float > > *":
        return _GRT.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _GRT.FloatVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "void":
        return _GRT.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _GRT.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _GRT.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _GRT.FloatVector___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _GRT.FloatVector_pop(self)

    def append(self, x: 'std::vector< float >::value_type const &') -> "void":
        return _GRT.FloatVector_append(self, x)

    def empty(self) -> "bool":
        return _GRT.FloatVector_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _GRT.FloatVector_size(self)

    def swap(self, v: 'FloatVector') -> "void":
        return _GRT.FloatVector_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _GRT.FloatVector_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _GRT.FloatVector_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _GRT.FloatVector_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _GRT.FloatVector_rend(self)

    def clear(self) -> "void":
        return _GRT.FloatVector_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _GRT.FloatVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _GRT.FloatVector_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _GRT.FloatVector_erase(self, *args)

    def __init__(self, *args):
        this = _GRT.new_FloatVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< float >::value_type const &') -> "void":
        return _GRT.FloatVector_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _GRT.FloatVector_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _GRT.FloatVector_back(self)

    def assign(self, n: 'std::vector< float >::size_type', x: 'std::vector< float >::value_type const &') -> "void":
        return _GRT.FloatVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _GRT.FloatVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _GRT.FloatVector_insert(self, *args)

    def reserve(self, n: 'std::vector< float >::size_type') -> "void":
        return _GRT.FloatVector_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _GRT.FloatVector_capacity(self)
    __swig_destroy__ = _GRT.delete_FloatVector
    __del__ = lambda self: None
FloatVector_swigregister = _GRT.FloatVector_swigregister
FloatVector_swigregister(FloatVector)

PI = _GRT.PI
TWO_PI = _GRT.TWO_PI
ONE_OVER_TWO_PI = _GRT.ONE_OVER_TWO_PI
SQRT_TWO_PI = _GRT.SQRT_TWO_PI

def grt_sqr(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_sqr(x)
grt_sqr = _GRT.grt_sqr

def grt_sqrt(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_sqrt(x)
grt_sqrt = _GRT.grt_sqrt

def grt_antilog(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_antilog(x)
grt_antilog = _GRT.grt_antilog

def grt_exp(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_exp(x)
grt_exp = _GRT.grt_exp

def grt_log(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_log(x)
grt_log = _GRT.grt_log

def grt_sigmoid(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_sigmoid(x)
grt_sigmoid = _GRT.grt_sigmoid
GRT_DEFAULT_NULL_CLASS_LABEL = _GRT.GRT_DEFAULT_NULL_CLASS_LABEL
GRT_SAFE_CHECKING = _GRT.GRT_SAFE_CHECKING
GRT_VERSION_MAJOR = _GRT.GRT_VERSION_MAJOR
GRT_VERSION_MINOR = _GRT.GRT_VERSION_MINOR
GRT_VERSION_PATCH = _GRT.GRT_VERSION_PATCH
GRT_VERSION = _GRT.GRT_VERSION
GRT_REVISION = _GRT.GRT_REVISION
class Util(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Util, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Util, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_Util()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Util
    __del__ = lambda self: None
    if _newclass:
        getCxx11Enabled = staticmethod(_GRT.Util_getCxx11Enabled)
    else:
        getCxx11Enabled = _GRT.Util_getCxx11Enabled
    if _newclass:
        sleep = staticmethod(_GRT.Util_sleep)
    else:
        sleep = _GRT.Util_sleep
    if _newclass:
        timeAsString = staticmethod(_GRT.Util_timeAsString)
    else:
        timeAsString = _GRT.Util_timeAsString
    if _newclass:
        intToString = staticmethod(_GRT.Util_intToString)
    else:
        intToString = _GRT.Util_intToString
    if _newclass:
        toString = staticmethod(_GRT.Util_toString)
    else:
        toString = _GRT.Util_toString
    if _newclass:
        stringToInt = staticmethod(_GRT.Util_stringToInt)
    else:
        stringToInt = _GRT.Util_stringToInt
    if _newclass:
        stringToDouble = staticmethod(_GRT.Util_stringToDouble)
    else:
        stringToDouble = _GRT.Util_stringToDouble
    if _newclass:
        stringToFloat = staticmethod(_GRT.Util_stringToFloat)
    else:
        stringToFloat = _GRT.Util_stringToFloat
    if _newclass:
        stringToBool = staticmethod(_GRT.Util_stringToBool)
    else:
        stringToBool = _GRT.Util_stringToBool
    if _newclass:
        stringEndsWith = staticmethod(_GRT.Util_stringEndsWith)
    else:
        stringEndsWith = _GRT.Util_stringEndsWith
    if _newclass:
        sum = staticmethod(_GRT.Util_sum)
    else:
        sum = _GRT.Util_sum
    if _newclass:
        dotProduct = staticmethod(_GRT.Util_dotProduct)
    else:
        dotProduct = _GRT.Util_dotProduct
    if _newclass:
        euclideanDistance = staticmethod(_GRT.Util_euclideanDistance)
    else:
        euclideanDistance = _GRT.Util_euclideanDistance
    if _newclass:
        squaredEuclideanDistance = staticmethod(_GRT.Util_squaredEuclideanDistance)
    else:
        squaredEuclideanDistance = _GRT.Util_squaredEuclideanDistance
    if _newclass:
        manhattanDistance = staticmethod(_GRT.Util_manhattanDistance)
    else:
        manhattanDistance = _GRT.Util_manhattanDistance
    if _newclass:
        cosineDistance = staticmethod(_GRT.Util_cosineDistance)
    else:
        cosineDistance = _GRT.Util_cosineDistance
    if _newclass:
        scale = staticmethod(_GRT.Util_scale)
    else:
        scale = _GRT.Util_scale
    if _newclass:
        normalize = staticmethod(_GRT.Util_normalize)
    else:
        normalize = _GRT.Util_normalize
    if _newclass:
        limit = staticmethod(_GRT.Util_limit)
    else:
        limit = _GRT.Util_limit
    if _newclass:
        getMinIndex = staticmethod(_GRT.Util_getMinIndex)
    else:
        getMinIndex = _GRT.Util_getMinIndex
    if _newclass:
        getMaxIndex = staticmethod(_GRT.Util_getMaxIndex)
    else:
        getMaxIndex = _GRT.Util_getMaxIndex
    if _newclass:
        getMin = staticmethod(_GRT.Util_getMin)
    else:
        getMin = _GRT.Util_getMin
    if _newclass:
        getMax = staticmethod(_GRT.Util_getMax)
    else:
        getMax = _GRT.Util_getMax
    if _newclass:
        getOS = staticmethod(_GRT.Util_getOS)
    else:
        getOS = _GRT.Util_getOS
    if _newclass:
        cartToPolar = staticmethod(_GRT.Util_cartToPolar)
    else:
        cartToPolar = _GRT.Util_cartToPolar
    if _newclass:
        polarToCart = staticmethod(_GRT.Util_polarToCart)
    else:
        polarToCart = _GRT.Util_polarToCart
    if _newclass:
        parseDirectory = staticmethod(_GRT.Util_parseDirectory)
    else:
        parseDirectory = _GRT.Util_parseDirectory
    OS_UNKNOWN = _GRT.Util_OS_UNKNOWN
    OS_OSX = _GRT.Util_OS_OSX
    OS_LINUX = _GRT.Util_OS_LINUX
    OS_WINDOWS = _GRT.Util_OS_WINDOWS
Util_swigregister = _GRT.Util_swigregister
Util_swigregister(Util)

def Util_getCxx11Enabled() -> "bool":
    return _GRT.Util_getCxx11Enabled()
Util_getCxx11Enabled = _GRT.Util_getCxx11Enabled

def Util_sleep(numMilliseconds: 'unsigned int const &') -> "bool":
    return _GRT.Util_sleep(numMilliseconds)
Util_sleep = _GRT.Util_sleep

def Util_timeAsString(includeDate: 'bool const'=True) -> "std::string":
    return _GRT.Util_timeAsString(includeDate)
Util_timeAsString = _GRT.Util_timeAsString

def Util_intToString(*args) -> "std::string":
    return _GRT.Util_intToString(*args)
Util_intToString = _GRT.Util_intToString

def Util_toString(*args) -> "std::string":
    return _GRT.Util_toString(*args)
Util_toString = _GRT.Util_toString

def Util_stringToInt(s: 'std::string const &') -> "int":
    return _GRT.Util_stringToInt(s)
Util_stringToInt = _GRT.Util_stringToInt

def Util_stringToDouble(s: 'std::string const &') -> "double":
    return _GRT.Util_stringToDouble(s)
Util_stringToDouble = _GRT.Util_stringToDouble

def Util_stringToFloat(s: 'std::string const &') -> "GRT::Float":
    return _GRT.Util_stringToFloat(s)
Util_stringToFloat = _GRT.Util_stringToFloat

def Util_stringToBool(s: 'std::string const &') -> "bool":
    return _GRT.Util_stringToBool(s)
Util_stringToBool = _GRT.Util_stringToBool

def Util_stringEndsWith(str: 'std::string const &', ending: 'std::string const &') -> "bool":
    return _GRT.Util_stringEndsWith(str, ending)
Util_stringEndsWith = _GRT.Util_stringEndsWith

def Util_sum(x: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_sum(x)
Util_sum = _GRT.Util_sum

def Util_dotProduct(a: 'VectorFloat', b: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_dotProduct(a, b)
Util_dotProduct = _GRT.Util_dotProduct

def Util_euclideanDistance(a: 'VectorFloat', b: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_euclideanDistance(a, b)
Util_euclideanDistance = _GRT.Util_euclideanDistance

def Util_squaredEuclideanDistance(a: 'VectorFloat', b: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_squaredEuclideanDistance(a, b)
Util_squaredEuclideanDistance = _GRT.Util_squaredEuclideanDistance

def Util_manhattanDistance(a: 'VectorFloat', b: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_manhattanDistance(a, b)
Util_manhattanDistance = _GRT.Util_manhattanDistance

def Util_cosineDistance(a: 'VectorFloat', b: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_cosineDistance(a, b)
Util_cosineDistance = _GRT.Util_cosineDistance

def Util_scale(*args) -> "GRT::VectorFloat":
    return _GRT.Util_scale(*args)
Util_scale = _GRT.Util_scale

def Util_normalize(x: 'VectorFloat') -> "GRT::VectorFloat":
    return _GRT.Util_normalize(x)
Util_normalize = _GRT.Util_normalize

def Util_limit(*args) -> "GRT::VectorFloat":
    return _GRT.Util_limit(*args)
Util_limit = _GRT.Util_limit

def Util_getMinIndex(x: 'VectorFloat') -> "unsigned int":
    return _GRT.Util_getMinIndex(x)
Util_getMinIndex = _GRT.Util_getMinIndex

def Util_getMaxIndex(x: 'VectorFloat') -> "unsigned int":
    return _GRT.Util_getMaxIndex(x)
Util_getMaxIndex = _GRT.Util_getMaxIndex

def Util_getMin(*args) -> "unsigned int":
    return _GRT.Util_getMin(*args)
Util_getMin = _GRT.Util_getMin

def Util_getMax(*args) -> "unsigned int":
    return _GRT.Util_getMax(*args)
Util_getMax = _GRT.Util_getMax

def Util_getOS() -> "unsigned int":
    return _GRT.Util_getOS()
Util_getOS = _GRT.Util_getOS

def Util_cartToPolar(x: 'GRT::Float const', y: 'GRT::Float const', r: 'GRT::Float &', theta: 'GRT::Float &') -> "void":
    return _GRT.Util_cartToPolar(x, y, r, theta)
Util_cartToPolar = _GRT.Util_cartToPolar

def Util_polarToCart(r: 'GRT::Float const', theta: 'GRT::Float const', x: 'GRT::Float &', y: 'GRT::Float &') -> "void":
    return _GRT.Util_polarToCart(r, theta, x, y)
Util_polarToCart = _GRT.Util_polarToCart

def Util_parseDirectory(directoryPath: 'std::string const', type: 'std::string const', filenames: 'std::vector< std::string,std::allocator< std::string > > &') -> "bool":
    return _GRT.Util_parseDirectory(directoryPath, type, filenames)
Util_parseDirectory = _GRT.Util_parseDirectory

class GRTBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GRTBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GRTBase, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_GRTBase(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GRTBase
    __del__ = lambda self: None

    def copyGRTBaseVariables(self, GRTBase: 'GRTBase') -> "bool":
        return _GRT.GRTBase_copyGRTBaseVariables(self, GRTBase)

    def getClassType(self) -> "std::string":
        return _GRT.GRTBase_getClassType(self)

    def getId(self) -> "std::string":
        return _GRT.GRTBase_getId(self)

    def getLastWarningMessage(self) -> "std::string":
        return _GRT.GRTBase_getLastWarningMessage(self)

    def getLastErrorMessage(self) -> "std::string":
        return _GRT.GRTBase_getLastErrorMessage(self)

    def getLastInfoMessage(self) -> "std::string":
        return _GRT.GRTBase_getLastInfoMessage(self)

    def setInfoLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.GRTBase_setInfoLoggingEnabled(self, loggingEnabled)

    def setWarningLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.GRTBase_setWarningLoggingEnabled(self, loggingEnabled)

    def setErrorLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.GRTBase_setErrorLoggingEnabled(self, loggingEnabled)

    def setDebugLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.GRTBase_setDebugLoggingEnabled(self, loggingEnabled)
    if _newclass:
        getGRTVersion = staticmethod(_GRT.GRTBase_getGRTVersion)
    else:
        getGRTVersion = _GRT.GRTBase_getGRTVersion
    if _newclass:
        getGRTRevison = staticmethod(_GRT.GRTBase_getGRTRevison)
    else:
        getGRTRevison = _GRT.GRTBase_getGRTRevison

    def getGRTBasePointer(self, *args) -> "GRT::GRTBase const *":
        return _GRT.GRTBase_getGRTBasePointer(self, *args)

    def scale(self, x: 'GRT::Float const &', minSource: 'GRT::Float const &', maxSource: 'GRT::Float const &', minTarget: 'GRT::Float const &', maxTarget: 'GRT::Float const &', constrain: 'bool const'=False) -> "GRT::Float":
        return _GRT.GRTBase_scale(self, x, minSource, maxSource, minTarget, maxTarget, constrain)

    def SQR(self, x: 'GRT::Float const &') -> "GRT::Float":
        return _GRT.GRTBase_SQR(self, x)
GRTBase_swigregister = _GRT.GRTBase_swigregister
GRTBase_swigregister(GRTBase)

def GRTBase_getGRTVersion(returnRevision: 'bool'=True) -> "std::string":
    return _GRT.GRTBase_getGRTVersion(returnRevision)
GRTBase_getGRTVersion = _GRT.GRTBase_getGRTVersion

def GRTBase_getGRTRevison() -> "std::string":
    return _GRT.GRTBase_getGRTRevison()
GRTBase_getGRTRevison = _GRT.GRTBase_getGRTRevison

class UINTVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UINTVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UINTVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _GRT.UINTVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _GRT.UINTVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _GRT.UINTVector___bool__(self)

    def __len__(self) -> "std::vector< UINT >::size_type":
        return _GRT.UINTVector___len__(self)

    def __getslice__(self, i: 'std::vector< UINT >::difference_type', j: 'std::vector< UINT >::difference_type') -> "std::vector< UINT,std::allocator< UINT > > *":
        return _GRT.UINTVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _GRT.UINTVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< UINT >::difference_type', j: 'std::vector< UINT >::difference_type') -> "void":
        return _GRT.UINTVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _GRT.UINTVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< UINT >::value_type const &":
        return _GRT.UINTVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _GRT.UINTVector___setitem__(self, *args)

    def pop(self) -> "std::vector< UINT >::value_type":
        return _GRT.UINTVector_pop(self)

    def append(self, x: 'std::vector< UINT >::value_type const &') -> "void":
        return _GRT.UINTVector_append(self, x)

    def empty(self) -> "bool":
        return _GRT.UINTVector_empty(self)

    def size(self) -> "std::vector< UINT >::size_type":
        return _GRT.UINTVector_size(self)

    def swap(self, v: 'UINTVector') -> "void":
        return _GRT.UINTVector_swap(self, v)

    def begin(self) -> "std::vector< UINT >::iterator":
        return _GRT.UINTVector_begin(self)

    def end(self) -> "std::vector< UINT >::iterator":
        return _GRT.UINTVector_end(self)

    def rbegin(self) -> "std::vector< UINT >::reverse_iterator":
        return _GRT.UINTVector_rbegin(self)

    def rend(self) -> "std::vector< UINT >::reverse_iterator":
        return _GRT.UINTVector_rend(self)

    def clear(self) -> "void":
        return _GRT.UINTVector_clear(self)

    def get_allocator(self) -> "std::vector< UINT >::allocator_type":
        return _GRT.UINTVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _GRT.UINTVector_pop_back(self)

    def erase(self, *args) -> "std::vector< UINT >::iterator":
        return _GRT.UINTVector_erase(self, *args)

    def __init__(self, *args):
        this = _GRT.new_UINTVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< UINT >::value_type const &') -> "void":
        return _GRT.UINTVector_push_back(self, x)

    def front(self) -> "std::vector< UINT >::value_type const &":
        return _GRT.UINTVector_front(self)

    def back(self) -> "std::vector< UINT >::value_type const &":
        return _GRT.UINTVector_back(self)

    def assign(self, n: 'std::vector< UINT >::size_type', x: 'std::vector< UINT >::value_type const &') -> "void":
        return _GRT.UINTVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _GRT.UINTVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _GRT.UINTVector_insert(self, *args)

    def reserve(self, n: 'std::vector< UINT >::size_type') -> "void":
        return _GRT.UINTVector_reserve(self, n)

    def capacity(self) -> "std::vector< UINT >::size_type":
        return _GRT.UINTVector_capacity(self)
    __swig_destroy__ = _GRT.delete_UINTVector
    __del__ = lambda self: None
UINTVector_swigregister = _GRT.UINTVector_swigregister
UINTVector_swigregister(UINTVector)

class VectorTUINT(UINTVector):
    __swig_setmethods__ = {}
    for _s in [UINTVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorTUINT, name, value)
    __swig_getmethods__ = {}
    for _s in [UINTVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorTUINT, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_VectorTUINT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_VectorTUINT
    __del__ = lambda self: None

    def resize(self, *args) -> "bool":
        return _GRT.VectorTUINT_resize(self, *args)

    def copy(self, rhs: 'VectorTUINT') -> "bool":
        return _GRT.VectorTUINT_copy(self, rhs)

    def fill(self, value: 'UINT const &') -> "bool":
        return _GRT.VectorTUINT_fill(self, value)

    def setAll(self, value: 'UINT const &') -> "bool":
        return _GRT.VectorTUINT_setAll(self, value)

    def getSize(self) -> "UINT":
        return _GRT.VectorTUINT_getSize(self)

    def getData(self, *args) -> "UINT const *":
        return _GRT.VectorTUINT_getData(self, *args)
VectorTUINT_swigregister = _GRT.VectorTUINT_swigregister
VectorTUINT_swigregister(VectorTUINT)

class VectorTFloat(DoubleVector):
    __swig_setmethods__ = {}
    for _s in [DoubleVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorTFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [DoubleVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorTFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_VectorTFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_VectorTFloat
    __del__ = lambda self: None

    def resize(self, *args) -> "bool":
        return _GRT.VectorTFloat_resize(self, *args)

    def copy(self, rhs: 'VectorTFloat') -> "bool":
        return _GRT.VectorTFloat_copy(self, rhs)

    def fill(self, value: 'double const &') -> "bool":
        return _GRT.VectorTFloat_fill(self, value)

    def setAll(self, value: 'double const &') -> "bool":
        return _GRT.VectorTFloat_setAll(self, value)

    def getSize(self) -> "UINT":
        return _GRT.VectorTFloat_getSize(self)

    def getData(self, *args) -> "double const *":
        return _GRT.VectorTFloat_getData(self, *args)
VectorTFloat_swigregister = _GRT.VectorTFloat_swigregister
VectorTFloat_swigregister(VectorTFloat)

class VectorFloat(VectorTFloat):
    __swig_setmethods__ = {}
    for _s in [VectorTFloat]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [VectorTFloat]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_VectorFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_VectorFloat
    __del__ = lambda self: None

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.VectorFloat_save(self, filename)

    def load(self, *args) -> "bool":
        return _GRT.VectorFloat_load(self, *args)

    def _print(self, *args) -> "bool":
        return _GRT.VectorFloat__print(self, *args)

    def scale(self, *args) -> "bool":
        return _GRT.VectorFloat_scale(self, *args)

    def getMinValue(self) -> "GRT::Float":
        return _GRT.VectorFloat_getMinValue(self)

    def getMaxValue(self) -> "GRT::Float":
        return _GRT.VectorFloat_getMaxValue(self)

    def getMean(self) -> "GRT::Float":
        return _GRT.VectorFloat_getMean(self)

    def getStdDev(self) -> "GRT::Float":
        return _GRT.VectorFloat_getStdDev(self)

    def getMinMax(self) -> "MinMax":
        return _GRT.VectorFloat_getMinMax(self)
VectorFloat_swigregister = _GRT.VectorFloat_swigregister
VectorFloat_swigregister(VectorFloat)

class MatrixTFloat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatrixTFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MatrixTFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MatrixTFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MatrixTFloat
    __del__ = lambda self: None

    def getRowVector(self, r: 'unsigned int const') -> "GRT::Vector< double >":
        return _GRT.MatrixTFloat_getRowVector(self, r)

    def getColVector(self, c: 'unsigned int const') -> "GRT::Vector< double >":
        return _GRT.MatrixTFloat_getColVector(self, c)

    def getConcatenatedVector(self, concatByRow: 'bool const'=True) -> "GRT::Vector< double >":
        return _GRT.MatrixTFloat_getConcatenatedVector(self, concatByRow)

    def resize(self, *args) -> "bool":
        return _GRT.MatrixTFloat_resize(self, *args)

    def copy(self, rhs: 'MatrixTFloat') -> "bool":
        return _GRT.MatrixTFloat_copy(self, rhs)

    def setAllValues(self, value: 'double const &') -> "bool":
        return _GRT.MatrixTFloat_setAllValues(self, value)

    def setAll(self, value: 'double const &') -> "bool":
        return _GRT.MatrixTFloat_setAll(self, value)

    def setRowVector(self, row: 'VectorTFloat', rowIndex: 'unsigned int const') -> "bool":
        return _GRT.MatrixTFloat_setRowVector(self, row, rowIndex)

    def setColVector(self, column: 'VectorTFloat', colIndex: 'unsigned int const') -> "bool":
        return _GRT.MatrixTFloat_setColVector(self, column, colIndex)

    def push_back(self, sample: 'VectorTFloat') -> "bool":
        return _GRT.MatrixTFloat_push_back(self, sample)

    def reserve(self, capacity: 'unsigned int const') -> "bool":
        return _GRT.MatrixTFloat_reserve(self, capacity)

    def clear(self) -> "bool":
        return _GRT.MatrixTFloat_clear(self)

    def getNumRows(self) -> "unsigned int":
        return _GRT.MatrixTFloat_getNumRows(self)

    def getNumCols(self) -> "unsigned int":
        return _GRT.MatrixTFloat_getNumCols(self)

    def getCapacity(self) -> "unsigned int":
        return _GRT.MatrixTFloat_getCapacity(self)

    def getSize(self) -> "unsigned int":
        return _GRT.MatrixTFloat_getSize(self)

    def getDataPointer(self) -> "double **":
        return _GRT.MatrixTFloat_getDataPointer(self)

    def getData(self) -> "double *":
        return _GRT.MatrixTFloat_getData(self)
MatrixTFloat_swigregister = _GRT.MatrixTFloat_swigregister
MatrixTFloat_swigregister(MatrixTFloat)

class MatrixFloat(MatrixTFloat):
    __swig_setmethods__ = {}
    for _s in [MatrixTFloat]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatrixFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [MatrixTFloat]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MatrixFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MatrixFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MatrixFloat
    __del__ = lambda self: None

    def getRow(self, r: 'unsigned int const') -> "GRT::VectorFloat":
        return _GRT.MatrixFloat_getRow(self, r)

    def getCol(self, c: 'unsigned int const') -> "GRT::VectorFloat":
        return _GRT.MatrixFloat_getCol(self, c)

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.MatrixFloat_save(self, filename)

    def load(self, *args) -> "bool":
        return _GRT.MatrixFloat_load(self, *args)

    def saveToCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.MatrixFloat_saveToCSVFile(self, filename)

    def loadFromCSVFile(self, *args) -> "bool":
        return _GRT.MatrixFloat_loadFromCSVFile(self, *args)

    def _print(self, *args) -> "bool":
        return _GRT.MatrixFloat__print(self, *args)

    def transpose(self) -> "bool":
        return _GRT.MatrixFloat_transpose(self)

    def scale(self, *args) -> "bool":
        return _GRT.MatrixFloat_scale(self, *args)

    def znorm(self, alpha: 'GRT::Float const'=0.001) -> "bool":
        return _GRT.MatrixFloat_znorm(self, alpha)

    def multiple(self, *args) -> "bool":
        return _GRT.MatrixFloat_multiple(self, *args)

    def add(self, *args) -> "bool":
        return _GRT.MatrixFloat_add(self, *args)

    def subtract(self, *args) -> "bool":
        return _GRT.MatrixFloat_subtract(self, *args)

    def getMinValue(self) -> "GRT::Float":
        return _GRT.MatrixFloat_getMinValue(self)

    def getMaxValue(self) -> "GRT::Float":
        return _GRT.MatrixFloat_getMaxValue(self)

    def getMean(self) -> "GRT::VectorFloat":
        return _GRT.MatrixFloat_getMean(self)

    def getStdDev(self) -> "GRT::VectorFloat":
        return _GRT.MatrixFloat_getStdDev(self)

    def getCovarianceMatrix(self) -> "GRT::MatrixFloat":
        return _GRT.MatrixFloat_getCovarianceMatrix(self)

    def getRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.MatrixFloat_getRanges(self)

    def getTrace(self) -> "GRT::Float":
        return _GRT.MatrixFloat_getTrace(self)
MatrixFloat_swigregister = _GRT.MatrixFloat_swigregister
MatrixFloat_swigregister(MatrixFloat)

class ClassificationData(GRTBase):
    __swig_setmethods__ = {}
    for _s in [GRTBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassificationData, name, value)
    __swig_getmethods__ = {}
    for _s in [GRTBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClassificationData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClassificationData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClassificationData
    __del__ = lambda self: None

    def clear(self) -> "void":
        return _GRT.ClassificationData_clear(self)

    def setNumDimensions(self, numDimensions: 'UINT') -> "bool":
        return _GRT.ClassificationData_setNumDimensions(self, numDimensions)

    def setDatasetName(self, datasetName: 'std::string') -> "bool":
        return _GRT.ClassificationData_setDatasetName(self, datasetName)

    def setInfoText(self, infoText: 'std::string') -> "bool":
        return _GRT.ClassificationData_setInfoText(self, infoText)

    def setClassNameForCorrespondingClassLabel(self, className: 'std::string const', classLabel: 'UINT const') -> "bool":
        return _GRT.ClassificationData_setClassNameForCorrespondingClassLabel(self, className, classLabel)

    def setAllowNullGestureClass(self, allowNullGestureClass: 'bool const') -> "bool":
        return _GRT.ClassificationData_setAllowNullGestureClass(self, allowNullGestureClass)

    def addSample(self, classLabel: 'UINT const', sample: 'VectorFloat') -> "bool":
        return _GRT.ClassificationData_addSample(self, classLabel, sample)

    def removeSample(self, index: 'UINT const') -> "bool":
        return _GRT.ClassificationData_removeSample(self, index)

    def removeLastSample(self) -> "bool":
        return _GRT.ClassificationData_removeLastSample(self)

    def reserve(self, M: 'UINT const') -> "bool":
        return _GRT.ClassificationData_reserve(self, M)

    def addClass(self, *args) -> "bool":
        return _GRT.ClassificationData_addClass(self, *args)

    def removeClass(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.ClassificationData_removeClass(self, classLabel)

    def eraseAllSamplesWithClassLabel(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.ClassificationData_eraseAllSamplesWithClassLabel(self, classLabel)

    def relabelAllSamplesWithClassLabel(self, oldClassLabel: 'UINT const', newClassLabel: 'UINT const') -> "bool":
        return _GRT.ClassificationData_relabelAllSamplesWithClassLabel(self, oldClassLabel, newClassLabel)

    def setExternalRanges(self, externalRanges: 'GRT::Vector< MinMax > const &', useExternalRanges: 'bool const'=False) -> "bool":
        return _GRT.ClassificationData_setExternalRanges(self, externalRanges, useExternalRanges)

    def enableExternalRangeScaling(self, useExternalRanges: 'bool const') -> "bool":
        return _GRT.ClassificationData_enableExternalRangeScaling(self, useExternalRanges)

    def scale(self, *args) -> "bool":
        return _GRT.ClassificationData_scale(self, *args)

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationData_save(self, filename)

    def load(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationData_load(self, filename)

    def saveDatasetToFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationData_saveDatasetToFile(self, filename)

    def loadDatasetFromFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationData_loadDatasetFromFile(self, filename)

    def saveDatasetToCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationData_saveDatasetToCSVFile(self, filename)

    def loadDatasetFromCSVFile(self, filename: 'std::string const &', classLabelColumnIndex: 'UINT const'=0) -> "bool":
        return _GRT.ClassificationData_loadDatasetFromCSVFile(self, filename, classLabelColumnIndex)

    def printStats(self) -> "bool":
        return _GRT.ClassificationData_printStats(self)

    def sortClassLabels(self) -> "bool":
        return _GRT.ClassificationData_sortClassLabels(self)

    def merge(self, data: 'ClassificationData') -> "bool":
        return _GRT.ClassificationData_merge(self, data)

    def partition(self, partitionPercentage: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "GRT::ClassificationData":
        return _GRT.ClassificationData_partition(self, partitionPercentage, useStratifiedSampling)

    def split(self, splitPercentage: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "GRT::ClassificationData":
        return _GRT.ClassificationData_split(self, splitPercentage, useStratifiedSampling)

    def spiltDataIntoKFolds(self, K: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "bool":
        return _GRT.ClassificationData_spiltDataIntoKFolds(self, K, useStratifiedSampling)

    def getTrainingFoldData(self, foldIndex: 'UINT const') -> "GRT::ClassificationData":
        return _GRT.ClassificationData_getTrainingFoldData(self, foldIndex)

    def getTestFoldData(self, foldIndex: 'UINT const') -> "GRT::ClassificationData":
        return _GRT.ClassificationData_getTestFoldData(self, foldIndex)

    def getClassData(self, classLabel: 'UINT const') -> "GRT::ClassificationData":
        return _GRT.ClassificationData_getClassData(self, classLabel)

    def getBootstrappedDataset(self, numSamples: 'UINT const'=0, balanceDataset: 'bool const'=False) -> "GRT::ClassificationData":
        return _GRT.ClassificationData_getBootstrappedDataset(self, numSamples, balanceDataset)

    def reformatAsRegressionData(self) -> "GRT::RegressionData":
        return _GRT.ClassificationData_reformatAsRegressionData(self)

    def reformatAsUnlabelledData(self) -> "GRT::UnlabelledData":
        return _GRT.ClassificationData_reformatAsUnlabelledData(self)

    def getDatasetName(self) -> "std::string":
        return _GRT.ClassificationData_getDatasetName(self)

    def getInfoText(self) -> "std::string":
        return _GRT.ClassificationData_getInfoText(self)

    def getStatsAsString(self) -> "std::string":
        return _GRT.ClassificationData_getStatsAsString(self)

    def getNumDimensions(self) -> "UINT":
        return _GRT.ClassificationData_getNumDimensions(self)

    def getNumSamples(self) -> "UINT":
        return _GRT.ClassificationData_getNumSamples(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.ClassificationData_getNumClasses(self)

    def getMinimumClassLabel(self) -> "UINT":
        return _GRT.ClassificationData_getMinimumClassLabel(self)

    def getMaximumClassLabel(self) -> "UINT":
        return _GRT.ClassificationData_getMaximumClassLabel(self)

    def getClassLabelIndexValue(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.ClassificationData_getClassLabelIndexValue(self, classLabel)

    def getClassNameForCorrespondingClassLabel(self, classLabel: 'UINT const') -> "std::string":
        return _GRT.ClassificationData_getClassNameForCorrespondingClassLabel(self, classLabel)

    def getRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.ClassificationData_getRanges(self)

    def getClassLabels(self) -> "GRT::Vector< UINT >":
        return _GRT.ClassificationData_getClassLabels(self)

    def getNumSamplesPerClass(self) -> "GRT::Vector< UINT >":
        return _GRT.ClassificationData_getNumSamplesPerClass(self)

    def getClassTracker(self) -> "GRT::Vector< ClassTracker >":
        return _GRT.ClassificationData_getClassTracker(self)

    def getClassHistogramData(self, classLabel: 'UINT const', numBins: 'UINT const') -> "GRT::MatrixFloat":
        return _GRT.ClassificationData_getClassHistogramData(self, classLabel, numBins)

    def getHistogramData(self, numBins: 'UINT const') -> "GRT::Vector< GRT::MatrixFloat >":
        return _GRT.ClassificationData_getHistogramData(self, numBins)

    def getClassificationData(self) -> "GRT::Vector< ClassificationSample >":
        return _GRT.ClassificationData_getClassificationData(self)

    def getClassProbabilities(self, *args) -> "GRT::VectorFloat":
        return _GRT.ClassificationData_getClassProbabilities(self, *args)

    def getMean(self) -> "GRT::VectorFloat":
        return _GRT.ClassificationData_getMean(self)

    def getStdDev(self) -> "GRT::VectorFloat":
        return _GRT.ClassificationData_getStdDev(self)

    def getClassMean(self) -> "GRT::MatrixFloat":
        return _GRT.ClassificationData_getClassMean(self)

    def getClassStdDev(self) -> "GRT::MatrixFloat":
        return _GRT.ClassificationData_getClassStdDev(self)

    def getCovarianceMatrix(self) -> "GRT::MatrixFloat":
        return _GRT.ClassificationData_getCovarianceMatrix(self)

    def getClassDataIndexes(self, classLabel: 'UINT const') -> "GRT::Vector< UINT >":
        return _GRT.ClassificationData_getClassDataIndexes(self, classLabel)

    def getDataAsMatrixDouble(self) -> "GRT::MatrixDouble":
        return _GRT.ClassificationData_getDataAsMatrixDouble(self)

    def getDataAsMatrixFloat(self) -> "GRT::MatrixFloat":
        return _GRT.ClassificationData_getDataAsMatrixFloat(self)
    if _newclass:
        generateGaussDataset = staticmethod(_GRT.ClassificationData_generateGaussDataset)
    else:
        generateGaussDataset = _GRT.ClassificationData_generateGaussDataset
    if _newclass:
        generateGaussLinearDataset = staticmethod(_GRT.ClassificationData_generateGaussLinearDataset)
    else:
        generateGaussLinearDataset = _GRT.ClassificationData_generateGaussLinearDataset

    def get(self, i: 'int const &') -> "GRT::ClassificationSample &":
        return _GRT.ClassificationData_get(self, i)
ClassificationData_swigregister = _GRT.ClassificationData_swigregister
ClassificationData_swigregister(ClassificationData)

def ClassificationData_generateGaussDataset(*args) -> "GRT::ClassificationData":
    return _GRT.ClassificationData_generateGaussDataset(*args)
ClassificationData_generateGaussDataset = _GRT.ClassificationData_generateGaussDataset

def ClassificationData_generateGaussLinearDataset(numSamples: 'UINT const'=10000, numClasses: 'UINT const'=10, numDimensions: 'UINT const'=3, range: 'GRT::Float const'=10, sigma: 'GRT::Float const'=1) -> "GRT::ClassificationData":
    return _GRT.ClassificationData_generateGaussLinearDataset(numSamples, numClasses, numDimensions, range, sigma)
ClassificationData_generateGaussLinearDataset = _GRT.ClassificationData_generateGaussLinearDataset

class ClassificationSample(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassificationSample, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClassificationSample, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClassificationSample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClassificationSample
    __del__ = lambda self: None

    def clear(self) -> "bool":
        return _GRT.ClassificationSample_clear(self)

    def getNumDimensions(self) -> "UINT":
        return _GRT.ClassificationSample_getNumDimensions(self)

    def getClassLabel(self) -> "UINT":
        return _GRT.ClassificationSample_getClassLabel(self)

    def getSample(self, *args) -> "GRT::VectorFloat &":
        return _GRT.ClassificationSample_getSample(self, *args)

    def set(self, classLabel: 'UINT', sample: 'VectorFloat') -> "bool":
        return _GRT.ClassificationSample_set(self, classLabel, sample)

    def setClassLabel(self, classLabel: 'UINT const') -> "bool":
        return _GRT.ClassificationSample_setClassLabel(self, classLabel)

    def setSample(self, sample: 'VectorFloat') -> "bool":
        return _GRT.ClassificationSample_setSample(self, sample)
ClassificationSample_swigregister = _GRT.ClassificationSample_swigregister
ClassificationSample_swigregister(ClassificationSample)

class TimeSeriesClassificationData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeSeriesClassificationData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeSeriesClassificationData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_TimeSeriesClassificationData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_TimeSeriesClassificationData
    __del__ = lambda self: None

    def clear(self) -> "void":
        return _GRT.TimeSeriesClassificationData_clear(self)

    def setNumDimensions(self, numDimensions: 'UINT const') -> "bool":
        return _GRT.TimeSeriesClassificationData_setNumDimensions(self, numDimensions)

    def setDatasetName(self, datasetName: 'std::string const') -> "bool":
        return _GRT.TimeSeriesClassificationData_setDatasetName(self, datasetName)

    def setInfoText(self, infoText: 'std::string const') -> "bool":
        return _GRT.TimeSeriesClassificationData_setInfoText(self, infoText)

    def setClassNameForCorrespondingClassLabel(self, className: 'std::string const', classLabel: 'UINT const') -> "bool":
        return _GRT.TimeSeriesClassificationData_setClassNameForCorrespondingClassLabel(self, className, classLabel)

    def setAllowNullGestureClass(self, allowNullGestureClass: 'bool const') -> "bool":
        return _GRT.TimeSeriesClassificationData_setAllowNullGestureClass(self, allowNullGestureClass)

    def addSample(self, classLabel: 'UINT const', trainingSample: 'MatrixFloat') -> "bool":
        return _GRT.TimeSeriesClassificationData_addSample(self, classLabel, trainingSample)

    def removeLastSample(self) -> "bool":
        return _GRT.TimeSeriesClassificationData_removeLastSample(self)

    def eraseAllSamplesWithClassLabel(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.TimeSeriesClassificationData_eraseAllSamplesWithClassLabel(self, classLabel)

    def relabelAllSamplesWithClassLabel(self, oldClassLabel: 'UINT const', newClassLabel: 'UINT const') -> "bool":
        return _GRT.TimeSeriesClassificationData_relabelAllSamplesWithClassLabel(self, oldClassLabel, newClassLabel)

    def setExternalRanges(self, externalRanges: 'GRT::Vector< MinMax > const &', useExternalRanges: 'bool const'=False) -> "bool":
        return _GRT.TimeSeriesClassificationData_setExternalRanges(self, externalRanges, useExternalRanges)

    def enableExternalRangeScaling(self, useExternalRanges: 'bool const') -> "bool":
        return _GRT.TimeSeriesClassificationData_enableExternalRangeScaling(self, useExternalRanges)

    def scale(self, *args) -> "bool":
        return _GRT.TimeSeriesClassificationData_scale(self, *args)

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.TimeSeriesClassificationData_save(self, filename)

    def load(self, filename: 'std::string const &') -> "bool":
        return _GRT.TimeSeriesClassificationData_load(self, filename)

    def saveDatasetToFile(self, filename: 'std::string const') -> "bool":
        return _GRT.TimeSeriesClassificationData_saveDatasetToFile(self, filename)

    def loadDatasetFromFile(self, filename: 'std::string const') -> "bool":
        return _GRT.TimeSeriesClassificationData_loadDatasetFromFile(self, filename)

    def saveDatasetToCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.TimeSeriesClassificationData_saveDatasetToCSVFile(self, filename)

    def loadDatasetFromCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.TimeSeriesClassificationData_loadDatasetFromCSVFile(self, filename)

    def printStats(self) -> "bool":
        return _GRT.TimeSeriesClassificationData_printStats(self)

    def getStatsAsString(self) -> "std::string":
        return _GRT.TimeSeriesClassificationData_getStatsAsString(self)

    def partition(self, partitionPercentage: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "GRT::TimeSeriesClassificationData":
        return _GRT.TimeSeriesClassificationData_partition(self, partitionPercentage, useStratifiedSampling)

    def split(self, partitionPercentage: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "GRT::TimeSeriesClassificationData":
        return _GRT.TimeSeriesClassificationData_split(self, partitionPercentage, useStratifiedSampling)

    def merge(self, labelledData: 'TimeSeriesClassificationData') -> "bool":
        return _GRT.TimeSeriesClassificationData_merge(self, labelledData)

    def spiltDataIntoKFolds(self, K: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "bool":
        return _GRT.TimeSeriesClassificationData_spiltDataIntoKFolds(self, K, useStratifiedSampling)

    def getTrainingFoldData(self, foldIndex: 'UINT const') -> "GRT::TimeSeriesClassificationData":
        return _GRT.TimeSeriesClassificationData_getTrainingFoldData(self, foldIndex)

    def getTestFoldData(self, foldIndex: 'UINT const') -> "GRT::TimeSeriesClassificationData":
        return _GRT.TimeSeriesClassificationData_getTestFoldData(self, foldIndex)

    def getClassData(self, classLabel: 'UINT const') -> "GRT::TimeSeriesClassificationData":
        return _GRT.TimeSeriesClassificationData_getClassData(self, classLabel)

    def reformatAsUnlabelledData(self) -> "GRT::UnlabelledData":
        return _GRT.TimeSeriesClassificationData_reformatAsUnlabelledData(self)

    def getDatasetName(self) -> "std::string":
        return _GRT.TimeSeriesClassificationData_getDatasetName(self)

    def getInfoText(self) -> "std::string":
        return _GRT.TimeSeriesClassificationData_getInfoText(self)

    def getNumDimensions(self) -> "UINT":
        return _GRT.TimeSeriesClassificationData_getNumDimensions(self)

    def getNumSamples(self) -> "UINT":
        return _GRT.TimeSeriesClassificationData_getNumSamples(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.TimeSeriesClassificationData_getNumClasses(self)

    def getMinimumClassLabel(self) -> "UINT":
        return _GRT.TimeSeriesClassificationData_getMinimumClassLabel(self)

    def getMaximumClassLabel(self) -> "UINT":
        return _GRT.TimeSeriesClassificationData_getMaximumClassLabel(self)

    def getClassLabelIndexValue(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.TimeSeriesClassificationData_getClassLabelIndexValue(self, classLabel)

    def getClassNameForCorrespondingClassLabel(self, classLabel: 'UINT const') -> "std::string":
        return _GRT.TimeSeriesClassificationData_getClassNameForCorrespondingClassLabel(self, classLabel)

    def getRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.TimeSeriesClassificationData_getRanges(self)

    def getClassTracker(self) -> "GRT::Vector< ClassTracker >":
        return _GRT.TimeSeriesClassificationData_getClassTracker(self)

    def getClassificationData(self) -> "GRT::Vector< TimeSeriesClassificationSample >":
        return _GRT.TimeSeriesClassificationData_getClassificationData(self)

    def getDataAsMatrixFloat(self) -> "GRT::MatrixFloat":
        return _GRT.TimeSeriesClassificationData_getDataAsMatrixFloat(self)

    def get(self, i: 'int const &') -> "GRT::TimeSeriesClassificationSample &":
        return _GRT.TimeSeriesClassificationData_get(self, i)
TimeSeriesClassificationData_swigregister = _GRT.TimeSeriesClassificationData_swigregister
TimeSeriesClassificationData_swigregister(TimeSeriesClassificationData)

class TimeSeriesClassificationSample(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeSeriesClassificationSample, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeSeriesClassificationSample, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_TimeSeriesClassificationSample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_TimeSeriesClassificationSample
    __del__ = lambda self: None

    def clear(self) -> "bool":
        return _GRT.TimeSeriesClassificationSample_clear(self)

    def addSample(self, classLabel: 'UINT const', sample: 'VectorFloat') -> "bool":
        return _GRT.TimeSeriesClassificationSample_addSample(self, classLabel, sample)

    def setTrainingSample(self, classLabel: 'UINT const', data: 'MatrixFloat') -> "bool":
        return _GRT.TimeSeriesClassificationSample_setTrainingSample(self, classLabel, data)

    def getLength(self) -> "UINT":
        return _GRT.TimeSeriesClassificationSample_getLength(self)

    def getNumDimensions(self) -> "UINT":
        return _GRT.TimeSeriesClassificationSample_getNumDimensions(self)

    def getClassLabel(self) -> "UINT":
        return _GRT.TimeSeriesClassificationSample_getClassLabel(self)

    def getData(self, *args) -> "GRT::MatrixFloat const &":
        return _GRT.TimeSeriesClassificationSample_getData(self, *args)
TimeSeriesClassificationSample_swigregister = _GRT.TimeSeriesClassificationSample_swigregister
TimeSeriesClassificationSample_swigregister(TimeSeriesClassificationSample)

DEFAULT_NULL_LIKELIHOOD_VALUE = _GRT.DEFAULT_NULL_LIKELIHOOD_VALUE
DEFAULT_NULL_DISTANCE_VALUE = _GRT.DEFAULT_NULL_DISTANCE_VALUE
class TrainingResultsObserverManager(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TrainingResultsObserverManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TrainingResultsObserverManager, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_TrainingResultsObserverManager()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_TrainingResultsObserverManager
    __del__ = lambda self: None
TrainingResultsObserverManager_swigregister = _GRT.TrainingResultsObserverManager_swigregister
TrainingResultsObserverManager_swigregister(TrainingResultsObserverManager)

class TestResultsObserverManager(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TestResultsObserverManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TestResultsObserverManager, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_TestResultsObserverManager()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_TestResultsObserverManager
    __del__ = lambda self: None
TestResultsObserverManager_swigregister = _GRT.TestResultsObserverManager_swigregister
TestResultsObserverManager_swigregister(TestResultsObserverManager)

class MLBase(GRTBase):
    __swig_setmethods__ = {}
    for _s in [GRTBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLBase, name, value)
    __swig_getmethods__ = {}
    for _s in [GRTBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MLBase, name)
    __repr__ = _swig_repr
    BASE_TYPE_NOT_SET = _GRT.MLBase_BASE_TYPE_NOT_SET
    CLASSIFIER = _GRT.MLBase_CLASSIFIER
    REGRESSIFIER = _GRT.MLBase_REGRESSIFIER
    CLUSTERER = _GRT.MLBase_CLUSTERER
    PRE_PROCSSING = _GRT.MLBase_PRE_PROCSSING
    POST_PROCESSING = _GRT.MLBase_POST_PROCESSING
    FEATURE_EXTRACTION = _GRT.MLBase_FEATURE_EXTRACTION
    CONTEXT = _GRT.MLBase_CONTEXT

    def __init__(self, *args):
        this = _GRT.new_MLBase(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MLBase
    __del__ = lambda self: None

    def copyMLBaseVariables(self, mlBase: 'MLBase') -> "bool":
        return _GRT.MLBase_copyMLBaseVariables(self, mlBase)

    def train(self, *args) -> "bool":
        return _GRT.MLBase_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.MLBase_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.MLBase_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.MLBase_predict_(self, *args)

    def map(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.MLBase_map(self, inputVector)

    def map_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.MLBase_map_(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.MLBase_reset(self)

    def clear(self) -> "bool":
        return _GRT.MLBase_clear(self)

    def _print(self) -> "bool":
        return _GRT.MLBase__print(self)

    def save(self, *args) -> "bool":
        return _GRT.MLBase_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.MLBase_load(self, *args)

    def saveModelToFile(self, *args) -> "bool":
        return _GRT.MLBase_saveModelToFile(self, *args)

    def loadModelFromFile(self, *args) -> "bool":
        return _GRT.MLBase_loadModelFromFile(self, *args)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.MLBase_getModel(self, stream)

    def getModelAsString(self) -> "std::string":
        return _GRT.MLBase_getModelAsString(self)

    def getInputType(self) -> "DataType":
        return _GRT.MLBase_getInputType(self)

    def getOutputType(self) -> "DataType":
        return _GRT.MLBase_getOutputType(self)

    def getType(self) -> "GRT::MLBase::BaseType":
        return _GRT.MLBase_getType(self)

    def getNumInputFeatures(self) -> "UINT":
        return _GRT.MLBase_getNumInputFeatures(self)

    def getNumInputDimensions(self) -> "UINT":
        return _GRT.MLBase_getNumInputDimensions(self)

    def getNumOutputDimensions(self) -> "UINT":
        return _GRT.MLBase_getNumOutputDimensions(self)

    def getMinNumEpochs(self) -> "UINT":
        return _GRT.MLBase_getMinNumEpochs(self)

    def getMaxNumEpochs(self) -> "UINT":
        return _GRT.MLBase_getMaxNumEpochs(self)

    def getBatchSize(self) -> "UINT":
        return _GRT.MLBase_getBatchSize(self)

    def getNumRestarts(self) -> "UINT":
        return _GRT.MLBase_getNumRestarts(self)

    def getValidationSetSize(self) -> "UINT":
        return _GRT.MLBase_getValidationSetSize(self)

    def getNumTrainingIterationsToConverge(self) -> "UINT":
        return _GRT.MLBase_getNumTrainingIterationsToConverge(self)

    def getLearningRate(self) -> "GRT::Float":
        return _GRT.MLBase_getLearningRate(self)

    def getRMSTrainingError(self) -> "GRT::Float":
        return _GRT.MLBase_getRMSTrainingError(self)

    def getRootMeanSquaredTrainingError(self) -> "GRT::Float":
        return _GRT.MLBase_getRootMeanSquaredTrainingError(self)

    def getTotalSquaredTrainingError(self) -> "GRT::Float":
        return _GRT.MLBase_getTotalSquaredTrainingError(self)

    def getRMSValidationError(self) -> "GRT::Float":
        return _GRT.MLBase_getRMSValidationError(self)

    def getValidationSetAccuracy(self) -> "GRT::Float":
        return _GRT.MLBase_getValidationSetAccuracy(self)

    def getValidationSetPrecision(self) -> "GRT::VectorFloat":
        return _GRT.MLBase_getValidationSetPrecision(self)

    def getValidationSetRecall(self) -> "GRT::VectorFloat":
        return _GRT.MLBase_getValidationSetRecall(self)

    def getUseValidationSet(self) -> "bool":
        return _GRT.MLBase_getUseValidationSet(self)

    def getTrained(self) -> "bool":
        return _GRT.MLBase_getTrained(self)

    def getModelTrained(self) -> "bool":
        return _GRT.MLBase_getModelTrained(self)

    def getConverged(self) -> "bool":
        return _GRT.MLBase_getConverged(self)

    def getScalingEnabled(self) -> "bool":
        return _GRT.MLBase_getScalingEnabled(self)

    def getIsBaseTypeClassifier(self) -> "bool":
        return _GRT.MLBase_getIsBaseTypeClassifier(self)

    def getIsBaseTypeRegressifier(self) -> "bool":
        return _GRT.MLBase_getIsBaseTypeRegressifier(self)

    def getIsBaseTypeClusterer(self) -> "bool":
        return _GRT.MLBase_getIsBaseTypeClusterer(self)

    def getTrainingLoggingEnabled(self) -> "bool":
        return _GRT.MLBase_getTrainingLoggingEnabled(self)

    def getTestingLoggingEnabled(self) -> "bool":
        return _GRT.MLBase_getTestingLoggingEnabled(self)

    def enableScaling(self, useScaling: 'bool const') -> "bool":
        return _GRT.MLBase_enableScaling(self, useScaling)

    def setMaxNumEpochs(self, maxNumEpochs: 'UINT const') -> "bool":
        return _GRT.MLBase_setMaxNumEpochs(self, maxNumEpochs)

    def setBatchSize(self, batchSize: 'UINT const') -> "bool":
        return _GRT.MLBase_setBatchSize(self, batchSize)

    def setMinNumEpochs(self, minNumEpochs: 'UINT const') -> "bool":
        return _GRT.MLBase_setMinNumEpochs(self, minNumEpochs)

    def setNumRestarts(self, numRestarts: 'UINT const') -> "bool":
        return _GRT.MLBase_setNumRestarts(self, numRestarts)

    def setMinChange(self, minChange: 'GRT::Float const') -> "bool":
        return _GRT.MLBase_setMinChange(self, minChange)

    def setLearningRate(self, learningRate: 'GRT::Float const') -> "bool":
        return _GRT.MLBase_setLearningRate(self, learningRate)

    def setUseValidationSet(self, useValidationSet: 'bool const') -> "bool":
        return _GRT.MLBase_setUseValidationSet(self, useValidationSet)

    def setValidationSetSize(self, validationSetSize: 'UINT const') -> "bool":
        return _GRT.MLBase_setValidationSetSize(self, validationSetSize)

    def setRandomiseTrainingOrder(self, randomiseTrainingOrder: 'bool const') -> "bool":
        return _GRT.MLBase_setRandomiseTrainingOrder(self, randomiseTrainingOrder)

    def setTrainingLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.MLBase_setTrainingLoggingEnabled(self, loggingEnabled)

    def setTestingLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.MLBase_setTestingLoggingEnabled(self, loggingEnabled)

    def registerTrainingResultsObserver(self, observer: 'Observer< TrainingResult > &') -> "bool":
        return _GRT.MLBase_registerTrainingResultsObserver(self, observer)

    def registerTestResultsObserver(self, observer: 'Observer< TestInstanceResult > &') -> "bool":
        return _GRT.MLBase_registerTestResultsObserver(self, observer)

    def removeTrainingResultsObserver(self, observer: 'Observer< TrainingResult > const &') -> "bool":
        return _GRT.MLBase_removeTrainingResultsObserver(self, observer)

    def removeTestResultsObserver(self, observer: 'Observer< TestInstanceResult > const &') -> "bool":
        return _GRT.MLBase_removeTestResultsObserver(self, observer)

    def removeAllTrainingObservers(self) -> "bool":
        return _GRT.MLBase_removeAllTrainingObservers(self)

    def removeAllTestObservers(self) -> "bool":
        return _GRT.MLBase_removeAllTestObservers(self)

    def notifyTrainingResultsObservers(self, data: 'TrainingResult const &') -> "bool":
        return _GRT.MLBase_notifyTrainingResultsObservers(self, data)

    def notifyTestResultsObservers(self, data: 'TestInstanceResult const &') -> "bool":
        return _GRT.MLBase_notifyTestResultsObservers(self, data)

    def getMLBasePointer(self, *args) -> "GRT::MLBase const *":
        return _GRT.MLBase_getMLBasePointer(self, *args)

    def getTrainingResults(self) -> "GRT::Vector< TrainingResult >":
        return _GRT.MLBase_getTrainingResults(self)
MLBase_swigregister = _GRT.MLBase_swigregister
MLBase_swigregister(MLBase)

class Classifier(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Classifier, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Classifier, name)
    __repr__ = _swig_repr
    STANDARD_CLASSIFIER_MODE = _GRT.Classifier_STANDARD_CLASSIFIER_MODE
    TIMESERIES_CLASSIFIER_MODE = _GRT.Classifier_TIMESERIES_CLASSIFIER_MODE

    def __init__(self, *args):
        this = _GRT.new_Classifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Classifier
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.Classifier_deepCopyFrom(self, classifier)

    def copyBaseVariables(self, classifier: 'Classifier') -> "bool":
        return _GRT.Classifier_copyBaseVariables(self, classifier)

    def reset(self) -> "bool":
        return _GRT.Classifier_reset(self)

    def clear(self) -> "bool":
        return _GRT.Classifier_clear(self)

    def computeAccuracy(self, data: 'ClassificationData', accuracy: 'GRT::Float &') -> "bool":
        return _GRT.Classifier_computeAccuracy(self, data, accuracy)

    def getClassifierType(self) -> "std::string":
        return _GRT.Classifier_getClassifierType(self)

    def getSupportsNullRejection(self) -> "bool":
        return _GRT.Classifier_getSupportsNullRejection(self)

    def getNullRejectionEnabled(self) -> "bool":
        return _GRT.Classifier_getNullRejectionEnabled(self)

    def getNullRejectionCoeff(self) -> "GRT::Float":
        return _GRT.Classifier_getNullRejectionCoeff(self)

    def getMaximumLikelihood(self) -> "GRT::Float":
        return _GRT.Classifier_getMaximumLikelihood(self)

    def getBestDistance(self) -> "GRT::Float":
        return _GRT.Classifier_getBestDistance(self)

    def getPhase(self) -> "GRT::Float":
        return _GRT.Classifier_getPhase(self)

    def getTrainingSetAccuracy(self) -> "GRT::Float":
        return _GRT.Classifier_getTrainingSetAccuracy(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.Classifier_getNumClasses(self)

    def getClassLabelIndexValue(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.Classifier_getClassLabelIndexValue(self, classLabel)

    def getPredictedClassLabel(self) -> "UINT":
        return _GRT.Classifier_getPredictedClassLabel(self)

    def getClassLikelihoods(self) -> "GRT::VectorFloat":
        return _GRT.Classifier_getClassLikelihoods(self)

    def getClassDistances(self) -> "GRT::VectorFloat":
        return _GRT.Classifier_getClassDistances(self)

    def getNullRejectionThresholds(self) -> "GRT::VectorFloat":
        return _GRT.Classifier_getNullRejectionThresholds(self)

    def getClassLabels(self) -> "GRT::Vector< UINT >":
        return _GRT.Classifier_getClassLabels(self)

    def getRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.Classifier_getRanges(self)

    def enableNullRejection(self, useNullRejection: 'bool const') -> "bool":
        return _GRT.Classifier_enableNullRejection(self, useNullRejection)

    def setNullRejectionCoeff(self, nullRejectionCoeff: 'GRT::Float const') -> "bool":
        return _GRT.Classifier_setNullRejectionCoeff(self, nullRejectionCoeff)

    def setNullRejectionThresholds(self, newRejectionThresholds: 'VectorFloat') -> "bool":
        return _GRT.Classifier_setNullRejectionThresholds(self, newRejectionThresholds)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.Classifier_recomputeNullRejectionThresholds(self)

    def getTimeseriesCompatible(self) -> "bool":
        return _GRT.Classifier_getTimeseriesCompatible(self)

    def create(self, *args) -> "GRT::Classifier *":
        return _GRT.Classifier_create(self, *args)

    def createNewInstance(self) -> "GRT::Classifier *":
        return _GRT.Classifier_createNewInstance(self)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.Classifier_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.Classifier_createInstanceFromString

    def deepCopy(self) -> "GRT::Classifier *":
        return _GRT.Classifier_deepCopy(self)

    def getClassifierPointer(self) -> "GRT::Classifier const *":
        return _GRT.Classifier_getClassifierPointer(self)

    def getBaseClassifier(self) -> "GRT::Classifier const &":
        return _GRT.Classifier_getBaseClassifier(self)
    if _newclass:
        getRegisteredClassifiers = staticmethod(_GRT.Classifier_getRegisteredClassifiers)
    else:
        getRegisteredClassifiers = _GRT.Classifier_getRegisteredClassifiers
Classifier_swigregister = _GRT.Classifier_swigregister
Classifier_swigregister(Classifier)

def Classifier_createInstanceFromString(id: 'std::string const &') -> "GRT::Classifier *":
    return _GRT.Classifier_createInstanceFromString(id)
Classifier_createInstanceFromString = _GRT.Classifier_createInstanceFromString

def Classifier_getRegisteredClassifiers() -> "GRT::Vector< std::string >":
    return _GRT.Classifier_getRegisteredClassifiers()
Classifier_getRegisteredClassifiers = _GRT.Classifier_getRegisteredClassifiers

INSERT_AT_END_INDEX = _GRT.INSERT_AT_END_INDEX
class GestureRecognitionPipeline(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GestureRecognitionPipeline, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GestureRecognitionPipeline, name)
    __repr__ = _swig_repr
    START_OF_PIPELINE = _GRT.GestureRecognitionPipeline_START_OF_PIPELINE
    AFTER_PREPROCESSING = _GRT.GestureRecognitionPipeline_AFTER_PREPROCESSING
    AFTER_FEATURE_EXTRACTION = _GRT.GestureRecognitionPipeline_AFTER_FEATURE_EXTRACTION
    AFTER_CLASSIFIER = _GRT.GestureRecognitionPipeline_AFTER_CLASSIFIER
    END_OF_PIPELINE = _GRT.GestureRecognitionPipeline_END_OF_PIPELINE
    NUM_CONTEXT_LEVELS = _GRT.GestureRecognitionPipeline_NUM_CONTEXT_LEVELS

    def __init__(self, *args):
        this = _GRT.new_GestureRecognitionPipeline(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GestureRecognitionPipeline
    __del__ = lambda self: None

    def __lshift__(self, *args) -> "GRT::GestureRecognitionPipeline &":
        return _GRT.GestureRecognitionPipeline___lshift__(self, *args)

    def test(self, *args) -> "bool":
        return _GRT.GestureRecognitionPipeline_test(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.GestureRecognitionPipeline_predict_(self, *args)

    def map_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.GestureRecognitionPipeline_map_(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_reset(self)

    def clear(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_clear(self)

    def clearModel(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_clearModel(self)

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_save(self, filename)

    def savePipelineToFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_savePipelineToFile(self, filename)

    def load(self, filename: 'std::string const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_load(self, filename)

    def loadPipelineFromFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_loadPipelineFromFile(self, filename)

    def preProcessData(self, inputVector: 'VectorFloat', computeFeatures: 'bool'=True) -> "bool":
        return _GRT.GestureRecognitionPipeline_preProcessData(self, inputVector, computeFeatures)

    def getIsInitialized(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsInitialized(self)

    def getIsPreProcessingSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsPreProcessingSet(self)

    def getIsFeatureExtractionSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsFeatureExtractionSet(self)

    def getIsClassifierSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsClassifierSet(self)

    def getIsRegressifierSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsRegressifierSet(self)

    def getIsClustererSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsClustererSet(self)

    def getIsPostProcessingSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsPostProcessingSet(self)

    def getIsContextSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsContextSet(self)

    def getIsPipelineModeSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsPipelineModeSet(self)

    def getIsPipelineInClassificationMode(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsPipelineInClassificationMode(self)

    def getIsPipelineInRegressionMode(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsPipelineInRegressionMode(self)

    def getInputVectorDimensionsSize(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getInputVectorDimensionsSize(self)

    def getOutputVectorDimensionsSize(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getOutputVectorDimensionsSize(self)

    def getNumClassesInModel(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumClassesInModel(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumClasses(self)

    def getNumPreProcessingModules(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumPreProcessingModules(self)

    def getNumFeatureExtractionModules(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumFeatureExtractionModules(self)

    def getNumPostProcessingModules(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumPostProcessingModules(self)

    def getPredictionModuleIndexPosition(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getPredictionModuleIndexPosition(self)

    def getPredictedClassLabel(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getPredictedClassLabel(self)

    def getUnProcessedPredictedClassLabel(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getUnProcessedPredictedClassLabel(self)

    def getNumTrainingSamples(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumTrainingSamples(self)

    def getNumTestSamples(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumTestSamples(self)

    def getMaximumLikelihood(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getMaximumLikelihood(self)

    def getPhase(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getPhase(self)

    def getTrainingSetAccuracy(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTrainingSetAccuracy(self)

    def getCrossValidationAccuracy(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getCrossValidationAccuracy(self)

    def getTestAccuracy(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestAccuracy(self)

    def getTestRMSError(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestRMSError(self)

    def getTestSSError(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestSSError(self)

    def getTestRejectionPrecision(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestRejectionPrecision(self)

    def getTestRejectionRecall(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestRejectionRecall(self)

    def getTestTime(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestTime(self)

    def getTrainingTime(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTrainingTime(self)

    def getTrainingRMSError(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTrainingRMSError(self)

    def getTrainingSSError(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTrainingSSError(self)

    def getTestConfusionMatrix(self) -> "GRT::MatrixFloat":
        return _GRT.GestureRecognitionPipeline_getTestConfusionMatrix(self)

    def getTrainingResults(self) -> "GRT::Vector< TrainingResult >":
        return _GRT.GestureRecognitionPipeline_getTrainingResults(self)

    def getTestResults(self) -> "TestResult":
        return _GRT.GestureRecognitionPipeline_getTestResults(self)

    def getTestPrecision(self, *args) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getTestPrecision(self, *args)

    def getTestRecall(self, *args) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getTestRecall(self, *args)

    def getTestFMeasure(self, *args) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getTestFMeasure(self, *args)

    def getClassLikelihoods(self) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getClassLikelihoods(self)

    def getClassDistances(self) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getClassDistances(self)

    def getNullRejectionThresholds(self) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getNullRejectionThresholds(self)

    def getRegressionData(self) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getRegressionData(self)

    def getUnProcessedRegressionData(self) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getUnProcessedRegressionData(self)

    def getPreProcessedData(self, *args) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getPreProcessedData(self, *args)

    def getFeatureExtractionData(self, *args) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getFeatureExtractionData(self, *args)

    def getClassLabels(self) -> "GRT::Vector< UINT >":
        return _GRT.GestureRecognitionPipeline_getClassLabels(self)

    def getTestInstanceResults(self) -> "GRT::Vector< TestInstanceResult >":
        return _GRT.GestureRecognitionPipeline_getTestInstanceResults(self)

    def getCrossValidationResults(self) -> "GRT::Vector< TestResult >":
        return _GRT.GestureRecognitionPipeline_getCrossValidationResults(self)

    def getPreProcessingModule(self, moduleIndex: 'UINT const') -> "PreProcessing *":
        return _GRT.GestureRecognitionPipeline_getPreProcessingModule(self, moduleIndex)

    def getFeatureExtractionModule(self, moduleIndex: 'UINT const') -> "FeatureExtraction *":
        return _GRT.GestureRecognitionPipeline_getFeatureExtractionModule(self, moduleIndex)

    def getClassifier(self) -> "GRT::Classifier *":
        return _GRT.GestureRecognitionPipeline_getClassifier(self)

    def getRegressifier(self) -> "Regressifier *":
        return _GRT.GestureRecognitionPipeline_getRegressifier(self)

    def getClusterer(self) -> "Clusterer *":
        return _GRT.GestureRecognitionPipeline_getClusterer(self)

    def getPostProcessingModule(self, moduleIndex: 'UINT') -> "PostProcessing *":
        return _GRT.GestureRecognitionPipeline_getPostProcessingModule(self, moduleIndex)

    def getContextModule(self, contextLevel: 'UINT const', moduleIndex: 'UINT const') -> "Context *":
        return _GRT.GestureRecognitionPipeline_getContextModule(self, contextLevel, moduleIndex)

    def getModelAsString(self) -> "std::string":
        return _GRT.GestureRecognitionPipeline_getModelAsString(self)

    def getPipelineModeAsString(self) -> "std::string":
        return _GRT.GestureRecognitionPipeline_getPipelineModeAsString(self)

    def getInfo(self) -> "std::string":
        return _GRT.GestureRecognitionPipeline_getInfo(self)

    def getPipelineModeFromString(self, pipelineMode: 'std::string') -> "UINT":
        return _GRT.GestureRecognitionPipeline_getPipelineModeFromString(self, pipelineMode)

    def addPreProcessingModule(self, preProcessingModule: 'PreProcessing const &', insertIndex: 'UINT'=99999) -> "bool":
        return _GRT.GestureRecognitionPipeline_addPreProcessingModule(self, preProcessingModule, insertIndex)

    def setPreProcessingModule(self, preProcessingModule: 'PreProcessing const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_setPreProcessingModule(self, preProcessingModule)

    def addFeatureExtractionModule(self, featureExtractionModule: 'FeatureExtraction const &', insertIndex: 'UINT'=99999) -> "bool":
        return _GRT.GestureRecognitionPipeline_addFeatureExtractionModule(self, featureExtractionModule, insertIndex)

    def setFeatureExtractionModule(self, featureExtractionModule: 'FeatureExtraction const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_setFeatureExtractionModule(self, featureExtractionModule)

    def setClassifier(self, classifier: 'Classifier') -> "bool":
        return _GRT.GestureRecognitionPipeline_setClassifier(self, classifier)

    def setRegressifier(self, regressifier: 'Regressifier const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_setRegressifier(self, regressifier)

    def setClusterer(self, clusterer: 'Clusterer const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_setClusterer(self, clusterer)

    def addPostProcessingModule(self, postProcessingModule: 'PostProcessing const &', insertIndex: 'UINT'=99999) -> "bool":
        return _GRT.GestureRecognitionPipeline_addPostProcessingModule(self, postProcessingModule, insertIndex)

    def setPostProcessingModule(self, postProcessingModule: 'PostProcessing const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_setPostProcessingModule(self, postProcessingModule)

    def addContextModule(self, contextModule: 'Context const &', contextLevel: 'UINT', insertIndex: 'UINT'=99999) -> "bool":
        return _GRT.GestureRecognitionPipeline_addContextModule(self, contextModule, contextLevel, insertIndex)

    def updateContextModule(self, value: 'bool', contextLevel: 'UINT'=0, moduleIndex: 'UINT'=0) -> "bool":
        return _GRT.GestureRecognitionPipeline_updateContextModule(self, value, contextLevel, moduleIndex)

    def removeAllPreProcessingModules(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeAllPreProcessingModules(self)

    def removePreProcessingModule(self, moduleIndex: 'UINT') -> "bool":
        return _GRT.GestureRecognitionPipeline_removePreProcessingModule(self, moduleIndex)

    def removeAllFeatureExtractionModules(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeAllFeatureExtractionModules(self)

    def removeFeatureExtractionModule(self, moduleIndex: 'UINT') -> "bool":
        return _GRT.GestureRecognitionPipeline_removeFeatureExtractionModule(self, moduleIndex)

    def removeClassifier(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeClassifier(self)

    def removeRegressifier(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeRegressifier(self)

    def removeClusterer(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeClusterer(self)

    def removeAllPostProcessingModules(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeAllPostProcessingModules(self)

    def removePostProcessingModule(self, moduleIndex: 'UINT const') -> "bool":
        return _GRT.GestureRecognitionPipeline_removePostProcessingModule(self, moduleIndex)

    def removeAllContextModules(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeAllContextModules(self)

    def removeContextModule(self, contextLevel: 'UINT const', moduleIndex: 'UINT const') -> "bool":
        return _GRT.GestureRecognitionPipeline_removeContextModule(self, contextLevel, moduleIndex)

    def clearAll(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_clearAll(self)

    def clearTestResults(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_clearTestResults(self)

    def setInfo(self, info: 'std::string const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_setInfo(self, info)

    def train(self, *args) -> "bool":
        return _GRT.GestureRecognitionPipeline_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.GestureRecognitionPipeline_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.GestureRecognitionPipeline_predict(self, *args)
GestureRecognitionPipeline_swigregister = _GRT.GestureRecognitionPipeline_swigregister
GestureRecognitionPipeline_swigregister(GestureRecognitionPipeline)

BIG_DISTANCE = _GRT.BIG_DISTANCE
class KNN(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KNN, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KNN, name)
    __repr__ = _swig_repr
    EUCLIDEAN_DISTANCE = _GRT.KNN_EUCLIDEAN_DISTANCE
    COSINE_DISTANCE = _GRT.KNN_COSINE_DISTANCE
    MANHATTAN_DISTANCE = _GRT.KNN_MANHATTAN_DISTANCE

    def __init__(self, *args):
        this = _GRT.new_KNN(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_KNN
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.KNN_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.KNN_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.KNN_recomputeNullRejectionThresholds(self)

    def getK(self) -> "UINT":
        return _GRT.KNN_getK(self)

    def getDistanceMethod(self) -> "UINT":
        return _GRT.KNN_getDistanceMethod(self)

    def setK(self, K: 'UINT') -> "bool":
        return _GRT.KNN_setK(self, K)

    def setMinKSearchValue(self, minKSearchValue: 'UINT') -> "bool":
        return _GRT.KNN_setMinKSearchValue(self, minKSearchValue)

    def setMaxKSearchValue(self, maxKSearchValue: 'UINT') -> "bool":
        return _GRT.KNN_setMaxKSearchValue(self, maxKSearchValue)

    def enableBestKValueSearch(self, searchForBestKValue: 'bool') -> "bool":
        return _GRT.KNN_enableBestKValueSearch(self, searchForBestKValue)

    def setNullRejectionCoeff(self, nullRejectionCoeff: 'GRT::Float') -> "bool":
        return _GRT.KNN_setNullRejectionCoeff(self, nullRejectionCoeff)

    def setDistanceMethod(self, distanceMethod: 'UINT') -> "bool":
        return _GRT.KNN_setDistanceMethod(self, distanceMethod)
    if _newclass:
        getId = staticmethod(_GRT.KNN_getId)
    else:
        getId = _GRT.KNN_getId

    def save(self, *args) -> "bool":
        return _GRT.KNN_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.KNN_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.KNN_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.KNN_predict_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.KNN_predict(self, *args)
KNN_swigregister = _GRT.KNN_swigregister
KNN_swigregister(KNN)

def KNN_getId() -> "std::string":
    return _GRT.KNN_getId()
KNN_getId = _GRT.KNN_getId

WEAK_CLASSIFIER_POSITIVE_CLASS_LABEL = _GRT.WEAK_CLASSIFIER_POSITIVE_CLASS_LABEL
WEAK_CLASSIFIER_NEGATIVE_CLASS_LABEL = _GRT.WEAK_CLASSIFIER_NEGATIVE_CLASS_LABEL
class WeakClassifier(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeakClassifier, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WeakClassifier, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _GRT.delete_WeakClassifier
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _GRT.new_WeakClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copyBaseVariables(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.WeakClassifier_copyBaseVariables(self, weakClassifer)

    def deepCopyFrom(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.WeakClassifier_deepCopyFrom(self, weakClassifer)

    def train(self, trainingData: 'ClassificationData', weights: 'VectorFloat') -> "bool":
        return _GRT.WeakClassifier_train(self, trainingData, weights)

    def predict(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.WeakClassifier_predict(self, x)

    def saveModelToFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.WeakClassifier_saveModelToFile(self, file)

    def loadModelFromFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.WeakClassifier_loadModelFromFile(self, file)

    def _print(self) -> "void":
        return _GRT.WeakClassifier__print(self)

    def getPositiveClassLabel(self) -> "GRT::Float":
        return _GRT.WeakClassifier_getPositiveClassLabel(self)

    def getNegativeClassLabel(self) -> "GRT::Float":
        return _GRT.WeakClassifier_getNegativeClassLabel(self)

    def getWeakClassifierType(self) -> "std::string":
        return _GRT.WeakClassifier_getWeakClassifierType(self)

    def getTrained(self) -> "bool":
        return _GRT.WeakClassifier_getTrained(self)

    def getNumInputDimensions(self) -> "UINT":
        return _GRT.WeakClassifier_getNumInputDimensions(self)

    def getTrainingLoggingEnabled(self) -> "bool":
        return _GRT.WeakClassifier_getTrainingLoggingEnabled(self)

    def setTrainingLoggingEnabled(self, enabled: 'bool const') -> "bool":
        return _GRT.WeakClassifier_setTrainingLoggingEnabled(self, enabled)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.WeakClassifier_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.WeakClassifier_createInstanceFromString

    def createNewInstance(self) -> "GRT::WeakClassifier *":
        return _GRT.WeakClassifier_createNewInstance(self)
WeakClassifier_swigregister = _GRT.WeakClassifier_swigregister
WeakClassifier_swigregister(WeakClassifier)

def WeakClassifier_createInstanceFromString(weakClassifierType: 'std::string const &') -> "GRT::WeakClassifier *":
    return _GRT.WeakClassifier_createInstanceFromString(weakClassifierType)
WeakClassifier_createInstanceFromString = _GRT.WeakClassifier_createInstanceFromString

class DecisionStump(WeakClassifier):
    __swig_setmethods__ = {}
    for _s in [WeakClassifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionStump, name, value)
    __swig_getmethods__ = {}
    for _s in [WeakClassifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionStump, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _GRT.delete_DecisionStump
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _GRT.new_DecisionStump(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def deepCopyFrom(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.DecisionStump_deepCopyFrom(self, weakClassifer)

    def train(self, trainingData: 'ClassificationData', weights: 'VectorFloat') -> "bool":
        return _GRT.DecisionStump_train(self, trainingData, weights)

    def predict(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.DecisionStump_predict(self, x)

    def saveModelToFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.DecisionStump_saveModelToFile(self, file)

    def loadModelFromFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.DecisionStump_loadModelFromFile(self, file)

    def _print(self) -> "void":
        return _GRT.DecisionStump__print(self)

    def getDecisionFeatureIndex(self) -> "UINT":
        return _GRT.DecisionStump_getDecisionFeatureIndex(self)

    def getDirection(self) -> "UINT":
        return _GRT.DecisionStump_getDirection(self)

    def getNumRandomSplits(self) -> "UINT":
        return _GRT.DecisionStump_getNumRandomSplits(self)

    def getDecisionValue(self) -> "GRT::Float":
        return _GRT.DecisionStump_getDecisionValue(self)
DecisionStump_swigregister = _GRT.DecisionStump_swigregister
DecisionStump_swigregister(DecisionStump)

class RadialBasisFunction(WeakClassifier):
    __swig_setmethods__ = {}
    for _s in [WeakClassifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadialBasisFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [WeakClassifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RadialBasisFunction, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _GRT.delete_RadialBasisFunction
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _GRT.new_RadialBasisFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def deepCopyFrom(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.RadialBasisFunction_deepCopyFrom(self, weakClassifer)

    def train(self, trainingData: 'ClassificationData', weights: 'VectorFloat') -> "bool":
        return _GRT.RadialBasisFunction_train(self, trainingData, weights)

    def predict(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.RadialBasisFunction_predict(self, x)

    def saveModelToFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.RadialBasisFunction_saveModelToFile(self, file)

    def loadModelFromFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.RadialBasisFunction_loadModelFromFile(self, file)

    def _print(self) -> "void":
        return _GRT.RadialBasisFunction__print(self)

    def getNumSteps(self) -> "UINT":
        return _GRT.RadialBasisFunction_getNumSteps(self)

    def getPositiveClassificationThreshold(self) -> "GRT::Float":
        return _GRT.RadialBasisFunction_getPositiveClassificationThreshold(self)

    def getAlpha(self) -> "GRT::Float":
        return _GRT.RadialBasisFunction_getAlpha(self)

    def getMinAlphaSearchRange(self) -> "GRT::Float":
        return _GRT.RadialBasisFunction_getMinAlphaSearchRange(self)

    def getMaxAlphaSearchRange(self) -> "GRT::Float":
        return _GRT.RadialBasisFunction_getMaxAlphaSearchRange(self)

    def getRBFCentre(self) -> "GRT::VectorFloat":
        return _GRT.RadialBasisFunction_getRBFCentre(self)
RadialBasisFunction_swigregister = _GRT.RadialBasisFunction_swigregister
RadialBasisFunction_swigregister(RadialBasisFunction)

class AdaBoost(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AdaBoost, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AdaBoost, name)
    __repr__ = _swig_repr
    MAX_POSITIVE_VALUE = _GRT.AdaBoost_MAX_POSITIVE_VALUE
    MAX_VALUE = _GRT.AdaBoost_MAX_VALUE

    def __init__(self, *args):
        this = _GRT.new_AdaBoost(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_AdaBoost
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.AdaBoost_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.AdaBoost_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.AdaBoost_recomputeNullRejectionThresholds(self)

    def setNullRejectionCoeff(self, nullRejectionCoeff: 'GRT::Float') -> "bool":
        return _GRT.AdaBoost_setNullRejectionCoeff(self, nullRejectionCoeff)

    def setWeakClassifier(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.AdaBoost_setWeakClassifier(self, weakClassifer)

    def addWeakClassifier(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.AdaBoost_addWeakClassifier(self, weakClassifer)

    def clearWeakClassifiers(self) -> "bool":
        return _GRT.AdaBoost_clearWeakClassifiers(self)

    def setNumBoostingIterations(self, numBoostingIterations: 'UINT') -> "bool":
        return _GRT.AdaBoost_setNumBoostingIterations(self, numBoostingIterations)

    def setPredictionMethod(self, predictionMethod: 'UINT') -> "bool":
        return _GRT.AdaBoost_setPredictionMethod(self, predictionMethod)

    def printModel(self) -> "void":
        return _GRT.AdaBoost_printModel(self)

    def getModels(self) -> "GRT::Vector< AdaBoostClassModel >":
        return _GRT.AdaBoost_getModels(self)
    if _newclass:
        getId = staticmethod(_GRT.AdaBoost_getId)
    else:
        getId = _GRT.AdaBoost_getId

    def save(self, *args) -> "bool":
        return _GRT.AdaBoost_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.AdaBoost_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.AdaBoost_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.AdaBoost_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.AdaBoost_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.AdaBoost_predict_(self, *args)
AdaBoost_swigregister = _GRT.AdaBoost_swigregister
AdaBoost_swigregister(AdaBoost)

def AdaBoost_getId() -> "std::string":
    return _GRT.AdaBoost_getId()
AdaBoost_getId = _GRT.AdaBoost_getId

class ANBC_Model(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ANBC_Model, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ANBC_Model, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_ANBC_Model()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ANBC_Model
    __del__ = lambda self: None

    def train(self, classLabel: 'UINT const', trainingData: 'MatrixFloat', weightsVector: 'VectorFloat') -> "bool":
        return _GRT.ANBC_Model_train(self, classLabel, trainingData, weightsVector)

    def predict(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.ANBC_Model_predict(self, x)

    def predictUnnormed(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.ANBC_Model_predictUnnormed(self, x)

    def gauss(self, x: 'GRT::Float const', mu: 'GRT::Float const', sigma: 'GRT::Float const') -> "GRT::Float":
        return _GRT.ANBC_Model_gauss(self, x, mu, sigma)

    def unnormedGauss(self, x: 'GRT::Float const', mu: 'GRT::Float const', sigma: 'GRT::Float const') -> "GRT::Float":
        return _GRT.ANBC_Model_unnormedGauss(self, x, mu, sigma)

    def recomputeThresholdValue(self, gamma: 'GRT::Float const') -> "void":
        return _GRT.ANBC_Model_recomputeThresholdValue(self, gamma)
    __swig_setmethods__["N"] = _GRT.ANBC_Model_N_set
    __swig_getmethods__["N"] = _GRT.ANBC_Model_N_get
    if _newclass:
        N = _swig_property(_GRT.ANBC_Model_N_get, _GRT.ANBC_Model_N_set)
    __swig_setmethods__["classLabel"] = _GRT.ANBC_Model_classLabel_set
    __swig_getmethods__["classLabel"] = _GRT.ANBC_Model_classLabel_get
    if _newclass:
        classLabel = _swig_property(_GRT.ANBC_Model_classLabel_get, _GRT.ANBC_Model_classLabel_set)
    __swig_setmethods__["threshold"] = _GRT.ANBC_Model_threshold_set
    __swig_getmethods__["threshold"] = _GRT.ANBC_Model_threshold_get
    if _newclass:
        threshold = _swig_property(_GRT.ANBC_Model_threshold_get, _GRT.ANBC_Model_threshold_set)
    __swig_setmethods__["gamma"] = _GRT.ANBC_Model_gamma_set
    __swig_getmethods__["gamma"] = _GRT.ANBC_Model_gamma_get
    if _newclass:
        gamma = _swig_property(_GRT.ANBC_Model_gamma_get, _GRT.ANBC_Model_gamma_set)
    __swig_setmethods__["trainingMu"] = _GRT.ANBC_Model_trainingMu_set
    __swig_getmethods__["trainingMu"] = _GRT.ANBC_Model_trainingMu_get
    if _newclass:
        trainingMu = _swig_property(_GRT.ANBC_Model_trainingMu_get, _GRT.ANBC_Model_trainingMu_set)
    __swig_setmethods__["trainingSigma"] = _GRT.ANBC_Model_trainingSigma_set
    __swig_getmethods__["trainingSigma"] = _GRT.ANBC_Model_trainingSigma_get
    if _newclass:
        trainingSigma = _swig_property(_GRT.ANBC_Model_trainingSigma_get, _GRT.ANBC_Model_trainingSigma_set)
    __swig_setmethods__["mu"] = _GRT.ANBC_Model_mu_set
    __swig_getmethods__["mu"] = _GRT.ANBC_Model_mu_get
    if _newclass:
        mu = _swig_property(_GRT.ANBC_Model_mu_get, _GRT.ANBC_Model_mu_set)
    __swig_setmethods__["sigma"] = _GRT.ANBC_Model_sigma_set
    __swig_getmethods__["sigma"] = _GRT.ANBC_Model_sigma_get
    if _newclass:
        sigma = _swig_property(_GRT.ANBC_Model_sigma_get, _GRT.ANBC_Model_sigma_set)
    __swig_setmethods__["weights"] = _GRT.ANBC_Model_weights_set
    __swig_getmethods__["weights"] = _GRT.ANBC_Model_weights_get
    if _newclass:
        weights = _swig_property(_GRT.ANBC_Model_weights_get, _GRT.ANBC_Model_weights_set)
ANBC_Model_swigregister = _GRT.ANBC_Model_swigregister
ANBC_Model_swigregister(ANBC_Model)

MIN_SCALE_VALUE = _GRT.MIN_SCALE_VALUE
MAX_SCALE_VALUE = _GRT.MAX_SCALE_VALUE
class ANBC(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ANBC, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ANBC, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ANBC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ANBC
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.ANBC_deepCopyFrom(self, classifier)

    def reset(self) -> "bool":
        return _GRT.ANBC_reset(self)

    def clear(self) -> "bool":
        return _GRT.ANBC_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.ANBC_recomputeNullRejectionThresholds(self)

    def getNullRejectionThresholds(self) -> "GRT::VectorFloat":
        return _GRT.ANBC_getNullRejectionThresholds(self)

    def getModels(self) -> "GRT::Vector< GRT::ANBC_Model >":
        return _GRT.ANBC_getModels(self)

    def setNullRejectionCoeff(self, nullRejectionCoeff: 'double') -> "bool":
        return _GRT.ANBC_setNullRejectionCoeff(self, nullRejectionCoeff)

    def setWeights(self, weightsData: 'ClassificationData') -> "bool":
        return _GRT.ANBC_setWeights(self, weightsData)

    def clearWeights(self) -> "bool":
        return _GRT.ANBC_clearWeights(self)
    if _newclass:
        getId = staticmethod(_GRT.ANBC_getId)
    else:
        getId = _GRT.ANBC_getId

    def save(self, *args) -> "bool":
        return _GRT.ANBC_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.ANBC_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.ANBC_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.ANBC_predict_(self, *args)
ANBC_swigregister = _GRT.ANBC_swigregister
ANBC_swigregister(ANBC)

def ANBC_getId() -> "std::string":
    return _GRT.ANBC_getId()
ANBC_getId = _GRT.ANBC_getId

class BAG(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BAG, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BAG, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_BAG(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_BAG
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.BAG_deepCopyFrom(self, classifier)

    def reset(self) -> "bool":
        return _GRT.BAG_reset(self)

    def clear(self) -> "bool":
        return _GRT.BAG_clear(self)

    def getEnsembleSize(self) -> "UINT":
        return _GRT.BAG_getEnsembleSize(self)

    def getEnsembleWeights(self) -> "GRT::VectorFloat":
        return _GRT.BAG_getEnsembleWeights(self)

    def getEnsemble(self) -> "GRT::Vector< GRT::Classifier * > const":
        return _GRT.BAG_getEnsemble(self)

    def addClassifierToEnsemble(self, classifier: 'Classifier', weight: 'GRT::Float'=1) -> "bool":
        return _GRT.BAG_addClassifierToEnsemble(self, classifier, weight)

    def clearEnsemble(self) -> "bool":
        return _GRT.BAG_clearEnsemble(self)

    def setWeights(self, weights: 'VectorFloat') -> "bool":
        return _GRT.BAG_setWeights(self, weights)
    if _newclass:
        getId = staticmethod(_GRT.BAG_getId)
    else:
        getId = _GRT.BAG_getId

    def save(self, *args) -> "bool":
        return _GRT.BAG_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.BAG_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.BAG_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.BAG_predict_(self, *args)
BAG_swigregister = _GRT.BAG_swigregister
BAG_swigregister(BAG)

def BAG_getId() -> "std::string":
    return _GRT.BAG_getId()
BAG_getId = _GRT.BAG_getId

class DecisionTreeNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionTreeNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionTreeNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_DecisionTreeNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DecisionTreeNode
    __del__ = lambda self: None

    def computeBestSplit(self, trainingMode: 'UINT const &', numSplittingSteps: 'UINT const &', trainingData: 'ClassificationData', features: 'VectorTUINT', classLabels: 'VectorTUINT', featureIndex: 'UINT &', minError: 'GRT::Float &') -> "bool":
        return _GRT.DecisionTreeNode_computeBestSplit(self, trainingMode, numSplittingSteps, trainingData, features, classLabels, featureIndex, minError)

    def clear(self) -> "bool":
        return _GRT.DecisionTreeNode_clear(self)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.DecisionTreeNode_getModel(self, stream)

    def deepCopy(self) -> "Node *":
        return _GRT.DecisionTreeNode_deepCopy(self)

    def getNodeSize(self) -> "UINT":
        return _GRT.DecisionTreeNode_getNodeSize(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.DecisionTreeNode_getNumClasses(self)

    def getClassProbabilities(self) -> "GRT::VectorFloat":
        return _GRT.DecisionTreeNode_getClassProbabilities(self)

    def setLeafNode(self, nodeSize: 'UINT const', classProbabilities: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeNode_setLeafNode(self, nodeSize, classProbabilities)

    def setNodeSize(self, nodeSize: 'UINT const') -> "bool":
        return _GRT.DecisionTreeNode_setNodeSize(self, nodeSize)

    def setClassProbabilities(self, classProbabilities: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeNode_setClassProbabilities(self, classProbabilities)
    if _newclass:
        getClassLabelIndexValue = staticmethod(_GRT.DecisionTreeNode_getClassLabelIndexValue)
    else:
        getClassLabelIndexValue = _GRT.DecisionTreeNode_getClassLabelIndexValue
DecisionTreeNode_swigregister = _GRT.DecisionTreeNode_swigregister
DecisionTreeNode_swigregister(DecisionTreeNode)

def DecisionTreeNode_getClassLabelIndexValue(classLabel: 'UINT', classLabels: 'VectorTUINT') -> "UINT":
    return _GRT.DecisionTreeNode_getClassLabelIndexValue(classLabel, classLabels)
DecisionTreeNode_getClassLabelIndexValue = _GRT.DecisionTreeNode_getClassLabelIndexValue

class DecisionTreeThresholdNode(DecisionTreeNode):
    __swig_setmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionTreeThresholdNode, name, value)
    __swig_getmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionTreeThresholdNode, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_DecisionTreeThresholdNode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DecisionTreeThresholdNode
    __del__ = lambda self: None

    def clear(self) -> "bool":
        return _GRT.DecisionTreeThresholdNode_clear(self)

    def _print(self) -> "bool":
        return _GRT.DecisionTreeThresholdNode__print(self)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.DecisionTreeThresholdNode_getModel(self, stream)

    def deepCopy(self) -> "Node *":
        return _GRT.DecisionTreeThresholdNode_deepCopy(self)

    def getFeatureIndex(self) -> "UINT":
        return _GRT.DecisionTreeThresholdNode_getFeatureIndex(self)

    def getThreshold(self) -> "GRT::Float":
        return _GRT.DecisionTreeThresholdNode_getThreshold(self)

    def set(self, nodeSize: 'UINT const', featureIndex: 'UINT const', threshold: 'GRT::Float const', classProbabilities: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeThresholdNode_set(self, nodeSize, featureIndex, threshold, classProbabilities)

    def predict_(self, *args) -> "bool":
        return _GRT.DecisionTreeThresholdNode_predict_(self, *args)
DecisionTreeThresholdNode_swigregister = _GRT.DecisionTreeThresholdNode_swigregister
DecisionTreeThresholdNode_swigregister(DecisionTreeThresholdNode)

class DecisionTreeTripleFeatureNode(DecisionTreeNode):
    __swig_setmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionTreeTripleFeatureNode, name, value)
    __swig_getmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionTreeTripleFeatureNode, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_DecisionTreeTripleFeatureNode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DecisionTreeTripleFeatureNode
    __del__ = lambda self: None

    def clear(self) -> "bool":
        return _GRT.DecisionTreeTripleFeatureNode_clear(self)

    def _print(self) -> "bool":
        return _GRT.DecisionTreeTripleFeatureNode__print(self)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.DecisionTreeTripleFeatureNode_getModel(self, stream)

    def deepCopy(self) -> "Node *":
        return _GRT.DecisionTreeTripleFeatureNode_deepCopy(self)

    def getFeatureIndexA(self) -> "UINT":
        return _GRT.DecisionTreeTripleFeatureNode_getFeatureIndexA(self)

    def getFeatureIndexB(self) -> "UINT":
        return _GRT.DecisionTreeTripleFeatureNode_getFeatureIndexB(self)

    def getFeatureIndexC(self) -> "UINT":
        return _GRT.DecisionTreeTripleFeatureNode_getFeatureIndexC(self)

    def set(self, nodeSize: 'UINT const', featureIndexA: 'UINT const', featureIndexB: 'UINT const', featureIndexC: 'UINT const', classProbabilities: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeTripleFeatureNode_set(self, nodeSize, featureIndexA, featureIndexB, featureIndexC, classProbabilities)

    def predict_(self, *args) -> "bool":
        return _GRT.DecisionTreeTripleFeatureNode_predict_(self, *args)
DecisionTreeTripleFeatureNode_swigregister = _GRT.DecisionTreeTripleFeatureNode_swigregister
DecisionTreeTripleFeatureNode_swigregister(DecisionTreeTripleFeatureNode)

class DecisionTreeClusterNode(DecisionTreeNode):
    __swig_setmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionTreeClusterNode, name, value)
    __swig_getmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionTreeClusterNode, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_DecisionTreeClusterNode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DecisionTreeClusterNode
    __del__ = lambda self: None

    def clear(self) -> "bool":
        return _GRT.DecisionTreeClusterNode_clear(self)

    def _print(self) -> "bool":
        return _GRT.DecisionTreeClusterNode__print(self)

    def computeFeatureWeights(self, weights: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeClusterNode_computeFeatureWeights(self, weights)

    def computeLeafNodeWeights(self, weights: 'MatrixFloat') -> "bool":
        return _GRT.DecisionTreeClusterNode_computeLeafNodeWeights(self, weights)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.DecisionTreeClusterNode_getModel(self, stream)

    def deepCopy(self) -> "Node *":
        return _GRT.DecisionTreeClusterNode_deepCopy(self)

    def getFeatureIndex(self) -> "UINT":
        return _GRT.DecisionTreeClusterNode_getFeatureIndex(self)

    def getThreshold(self) -> "GRT::Float":
        return _GRT.DecisionTreeClusterNode_getThreshold(self)

    def set(self, nodeSize: 'UINT const', featureIndex: 'UINT const', threshold: 'GRT::Float const', classProbabilities: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeClusterNode_set(self, nodeSize, featureIndex, threshold, classProbabilities)

    def predict_(self, *args) -> "bool":
        return _GRT.DecisionTreeClusterNode_predict_(self, *args)
DecisionTreeClusterNode_swigregister = _GRT.DecisionTreeClusterNode_swigregister
DecisionTreeClusterNode_swigregister(DecisionTreeClusterNode)

class DecisionTree(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionTree, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionTree, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_DecisionTree(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DecisionTree
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.DecisionTree_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.DecisionTree_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.DecisionTree_recomputeNullRejectionThresholds(self)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.DecisionTree_getModel(self, stream)

    def deepCopyTree(self) -> "GRT::DecisionTreeNode *":
        return _GRT.DecisionTree_deepCopyTree(self)

    def deepCopyDecisionTreeNode(self) -> "GRT::DecisionTreeNode *":
        return _GRT.DecisionTree_deepCopyDecisionTreeNode(self)

    def getTree(self) -> "GRT::DecisionTreeNode const *":
        return _GRT.DecisionTree_getTree(self)

    def getTrainingMode(self) -> "Tree::TrainingMode":
        return _GRT.DecisionTree_getTrainingMode(self)

    def getNumSplittingSteps(self) -> "UINT":
        return _GRT.DecisionTree_getNumSplittingSteps(self)

    def getMinNumSamplesPerNode(self) -> "UINT":
        return _GRT.DecisionTree_getMinNumSamplesPerNode(self)

    def getMaxDepth(self) -> "UINT":
        return _GRT.DecisionTree_getMaxDepth(self)

    def getPredictedNodeID(self) -> "UINT":
        return _GRT.DecisionTree_getPredictedNodeID(self)

    def getRemoveFeaturesAtEachSplit(self) -> "bool":
        return _GRT.DecisionTree_getRemoveFeaturesAtEachSplit(self)

    def setTrainingMode(self, trainingMode: 'Tree::TrainingMode const') -> "bool":
        return _GRT.DecisionTree_setTrainingMode(self, trainingMode)

    def setNumSplittingSteps(self, numSplittingSteps: 'UINT const') -> "bool":
        return _GRT.DecisionTree_setNumSplittingSteps(self, numSplittingSteps)

    def setMinNumSamplesPerNode(self, minNumSamplesPerNode: 'UINT const') -> "bool":
        return _GRT.DecisionTree_setMinNumSamplesPerNode(self, minNumSamplesPerNode)

    def setMaxDepth(self, maxDepth: 'UINT const') -> "bool":
        return _GRT.DecisionTree_setMaxDepth(self, maxDepth)

    def setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit: 'bool const') -> "bool":
        return _GRT.DecisionTree_setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit)

    def setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt: 'bool const') -> "bool":
        return _GRT.DecisionTree_setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt)

    def setDecisionTreeNode(self, node: 'DecisionTreeNode') -> "bool":
        return _GRT.DecisionTree_setDecisionTreeNode(self, node)
    if _newclass:
        getId = staticmethod(_GRT.DecisionTree_getId)
    else:
        getId = _GRT.DecisionTree_getId

    def save(self, *args) -> "bool":
        return _GRT.DecisionTree_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.DecisionTree_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.DecisionTree_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.DecisionTree_predict_(self, *args)
DecisionTree_swigregister = _GRT.DecisionTree_swigregister
DecisionTree_swigregister(DecisionTree)

def DecisionTree_getId() -> "std::string":
    return _GRT.DecisionTree_getId()
DecisionTree_getId = _GRT.DecisionTree_getId

class IndexDist(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexDist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IndexDist, name)
    __repr__ = _swig_repr

    def __init__(self, x: 'int'=0, y: 'int'=0, dist: 'GRT::Float'=0):
        this = _GRT.new_IndexDist(x, y, dist)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_IndexDist
    __del__ = lambda self: None
    __swig_setmethods__["x"] = _GRT.IndexDist_x_set
    __swig_getmethods__["x"] = _GRT.IndexDist_x_get
    if _newclass:
        x = _swig_property(_GRT.IndexDist_x_get, _GRT.IndexDist_x_set)
    __swig_setmethods__["y"] = _GRT.IndexDist_y_set
    __swig_getmethods__["y"] = _GRT.IndexDist_y_get
    if _newclass:
        y = _swig_property(_GRT.IndexDist_y_get, _GRT.IndexDist_y_set)
    __swig_setmethods__["dist"] = _GRT.IndexDist_dist_set
    __swig_getmethods__["dist"] = _GRT.IndexDist_dist_get
    if _newclass:
        dist = _swig_property(_GRT.IndexDist_dist_get, _GRT.IndexDist_dist_set)
IndexDist_swigregister = _GRT.IndexDist_swigregister
IndexDist_swigregister(IndexDist)

class DTWTemplate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DTWTemplate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DTWTemplate, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_DTWTemplate()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DTWTemplate
    __del__ = lambda self: None
    __swig_setmethods__["classLabel"] = _GRT.DTWTemplate_classLabel_set
    __swig_getmethods__["classLabel"] = _GRT.DTWTemplate_classLabel_get
    if _newclass:
        classLabel = _swig_property(_GRT.DTWTemplate_classLabel_get, _GRT.DTWTemplate_classLabel_set)
    __swig_setmethods__["timeSeries"] = _GRT.DTWTemplate_timeSeries_set
    __swig_getmethods__["timeSeries"] = _GRT.DTWTemplate_timeSeries_get
    if _newclass:
        timeSeries = _swig_property(_GRT.DTWTemplate_timeSeries_get, _GRT.DTWTemplate_timeSeries_set)
    __swig_setmethods__["trainingMu"] = _GRT.DTWTemplate_trainingMu_set
    __swig_getmethods__["trainingMu"] = _GRT.DTWTemplate_trainingMu_get
    if _newclass:
        trainingMu = _swig_property(_GRT.DTWTemplate_trainingMu_get, _GRT.DTWTemplate_trainingMu_set)
    __swig_setmethods__["trainingSigma"] = _GRT.DTWTemplate_trainingSigma_set
    __swig_getmethods__["trainingSigma"] = _GRT.DTWTemplate_trainingSigma_get
    if _newclass:
        trainingSigma = _swig_property(_GRT.DTWTemplate_trainingSigma_get, _GRT.DTWTemplate_trainingSigma_set)
    __swig_setmethods__["averageTemplateLength"] = _GRT.DTWTemplate_averageTemplateLength_set
    __swig_getmethods__["averageTemplateLength"] = _GRT.DTWTemplate_averageTemplateLength_get
    if _newclass:
        averageTemplateLength = _swig_property(_GRT.DTWTemplate_averageTemplateLength_get, _GRT.DTWTemplate_averageTemplateLength_set)
DTWTemplate_swigregister = _GRT.DTWTemplate_swigregister
DTWTemplate_swigregister(DTWTemplate)

class DTW(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DTW, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DTW, name)
    __repr__ = _swig_repr
    ABSOLUTE_DIST = _GRT.DTW_ABSOLUTE_DIST
    EUCLIDEAN_DIST = _GRT.DTW_EUCLIDEAN_DIST
    NORM_ABSOLUTE_DIST = _GRT.DTW_NORM_ABSOLUTE_DIST
    TEMPLATE_THRESHOLDS = _GRT.DTW_TEMPLATE_THRESHOLDS
    CLASS_LIKELIHOODS = _GRT.DTW_CLASS_LIKELIHOODS
    THRESHOLDS_AND_LIKELIHOODS = _GRT.DTW_THRESHOLDS_AND_LIKELIHOODS

    def __init__(self, *args):
        this = _GRT.new_DTW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DTW
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.DTW_deepCopyFrom(self, classifier)

    def predict_(self, *args) -> "bool":
        return _GRT.DTW_predict_(self, *args)

    def reset(self) -> "bool":
        return _GRT.DTW_reset(self)

    def clear(self) -> "bool":
        return _GRT.DTW_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.DTW_recomputeNullRejectionThresholds(self)

    def getNumTemplates(self) -> "UINT":
        return _GRT.DTW_getNumTemplates(self)

    def setRejectionMode(self, rejectionMode: 'UINT') -> "bool":
        return _GRT.DTW_setRejectionMode(self, rejectionMode)

    def setNullRejectionThreshold(self, nullRejectionLikelihoodThreshold: 'GRT::Float') -> "bool":
        return _GRT.DTW_setNullRejectionThreshold(self, nullRejectionLikelihoodThreshold)

    def setOffsetTimeseriesUsingFirstSample(self, offsetUsingFirstSample: 'bool') -> "bool":
        return _GRT.DTW_setOffsetTimeseriesUsingFirstSample(self, offsetUsingFirstSample)

    def setContrainWarpingPath(self, constrain: 'bool') -> "bool":
        return _GRT.DTW_setContrainWarpingPath(self, constrain)

    def setWarpingRadius(self, radius: 'GRT::Float') -> "bool":
        return _GRT.DTW_setWarpingRadius(self, radius)

    def getRejectionMode(self) -> "UINT":
        return _GRT.DTW_getRejectionMode(self)

    def enableZNormalization(self, useZNormalization: 'bool', constrainZNorm: 'bool'=True) -> "bool":
        return _GRT.DTW_enableZNormalization(self, useZNormalization, constrainZNorm)

    def enableTrimTrainingData(self, trimTrainingData: 'bool', trimThreshold: 'GRT::Float', maximumTrimPercentage: 'GRT::Float') -> "bool":
        return _GRT.DTW_enableTrimTrainingData(self, trimTrainingData, trimThreshold, maximumTrimPercentage)

    def getModels(self) -> "GRT::Vector< GRT::DTWTemplate >":
        return _GRT.DTW_getModels(self)

    def setModels(self, newTemplates: 'GRT::Vector< GRT::DTWTemplate >') -> "bool":
        return _GRT.DTW_setModels(self, newTemplates)

    def getInputDataBuffer(self) -> "GRT::Vector< GRT::VectorFloat >":
        return _GRT.DTW_getInputDataBuffer(self)

    def getDistanceMatrices(self) -> "GRT::Vector< GRT::MatrixFloat > const &":
        return _GRT.DTW_getDistanceMatrices(self)

    def getWarpingPaths(self) -> "GRT::Vector< GRT::Vector< GRT::IndexDist > > const &":
        return _GRT.DTW_getWarpingPaths(self)
    if _newclass:
        getId = staticmethod(_GRT.DTW_getId)
    else:
        getId = _GRT.DTW_getId

    def save(self, *args) -> "bool":
        return _GRT.DTW_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.DTW_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.DTW_train_(self, *args)
DTW_swigregister = _GRT.DTW_swigregister
DTW_swigregister(DTW)

def DTW_getId() -> "std::string":
    return _GRT.DTW_getId()
DTW_getId = _GRT.DTW_getId

class FSMParticle(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FSMParticle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FSMParticle, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_FSMParticle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_FSMParticle
    __del__ = lambda self: None
    __swig_setmethods__["currentState"] = _GRT.FSMParticle_currentState_set
    __swig_getmethods__["currentState"] = _GRT.FSMParticle_currentState_get
    if _newclass:
        currentState = _swig_property(_GRT.FSMParticle_currentState_get, _GRT.FSMParticle_currentState_set)
FSMParticle_swigregister = _GRT.FSMParticle_swigregister
FSMParticle_swigregister(FSMParticle)

class FiniteStateMachine(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FiniteStateMachine, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FiniteStateMachine, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_FiniteStateMachine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_FiniteStateMachine
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.FiniteStateMachine_deepCopyFrom(self, classifier)

    def reset(self) -> "bool":
        return _GRT.FiniteStateMachine_reset(self)

    def clear(self) -> "bool":
        return _GRT.FiniteStateMachine_clear(self)

    def _print(self) -> "bool":
        return _GRT.FiniteStateMachine__print(self)

    def setNumParticles(self, numParticles: 'UINT const') -> "bool":
        return _GRT.FiniteStateMachine_setNumParticles(self, numParticles)

    def setNumClustersPerState(self, numClustersPerState: 'UINT const') -> "bool":
        return _GRT.FiniteStateMachine_setNumClustersPerState(self, numClustersPerState)

    def setStateTransitionSmoothingCoeff(self, stateTransitionSmoothingCoeff: 'GRT::Float const') -> "bool":
        return _GRT.FiniteStateMachine_setStateTransitionSmoothingCoeff(self, stateTransitionSmoothingCoeff)

    def setMeasurementNoise(self, measurementNoise: 'GRT::Float const') -> "bool":
        return _GRT.FiniteStateMachine_setMeasurementNoise(self, measurementNoise)
    if _newclass:
        getId = staticmethod(_GRT.FiniteStateMachine_getId)
    else:
        getId = _GRT.FiniteStateMachine_getId

    def save(self, *args) -> "bool":
        return _GRT.FiniteStateMachine_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.FiniteStateMachine_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.FiniteStateMachine_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.FiniteStateMachine_predict_(self, *args)
FiniteStateMachine_swigregister = _GRT.FiniteStateMachine_swigregister
FiniteStateMachine_swigregister(FiniteStateMachine)

def FiniteStateMachine_getId() -> "std::string":
    return _GRT.FiniteStateMachine_getId()
FiniteStateMachine_getId = _GRT.FiniteStateMachine_getId

class GuassModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GuassModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GuassModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_GuassModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GuassModel
    __del__ = lambda self: None

    def printModelValues(self) -> "bool":
        return _GRT.GuassModel_printModelValues(self)
    __swig_setmethods__["det"] = _GRT.GuassModel_det_set
    __swig_getmethods__["det"] = _GRT.GuassModel_det_get
    if _newclass:
        det = _swig_property(_GRT.GuassModel_det_get, _GRT.GuassModel_det_set)
    __swig_setmethods__["mu"] = _GRT.GuassModel_mu_set
    __swig_getmethods__["mu"] = _GRT.GuassModel_mu_get
    if _newclass:
        mu = _swig_property(_GRT.GuassModel_mu_get, _GRT.GuassModel_mu_set)
    __swig_setmethods__["sigma"] = _GRT.GuassModel_sigma_set
    __swig_getmethods__["sigma"] = _GRT.GuassModel_sigma_get
    if _newclass:
        sigma = _swig_property(_GRT.GuassModel_sigma_get, _GRT.GuassModel_sigma_set)
    __swig_setmethods__["invSigma"] = _GRT.GuassModel_invSigma_set
    __swig_getmethods__["invSigma"] = _GRT.GuassModel_invSigma_get
    if _newclass:
        invSigma = _swig_property(_GRT.GuassModel_invSigma_get, _GRT.GuassModel_invSigma_set)
GuassModel_swigregister = _GRT.GuassModel_swigregister
GuassModel_swigregister(GuassModel)

class MixtureModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MixtureModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MixtureModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_MixtureModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MixtureModel
    __del__ = lambda self: None

    def computeMixtureLikelihood(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.MixtureModel_computeMixtureLikelihood(self, x)

    def resize(self, K: 'UINT') -> "bool":
        return _GRT.MixtureModel_resize(self, K)

    def recomputeNullRejectionThreshold(self, gamma: 'GRT::Float') -> "bool":
        return _GRT.MixtureModel_recomputeNullRejectionThreshold(self, gamma)

    def recomputeNormalizationFactor(self) -> "bool":
        return _GRT.MixtureModel_recomputeNormalizationFactor(self)

    def printModelValues(self) -> "bool":
        return _GRT.MixtureModel_printModelValues(self)

    def getK(self) -> "UINT":
        return _GRT.MixtureModel_getK(self)

    def getClassLabel(self) -> "UINT":
        return _GRT.MixtureModel_getClassLabel(self)

    def getTrainingMu(self) -> "GRT::Float":
        return _GRT.MixtureModel_getTrainingMu(self)

    def getTrainingSigma(self) -> "GRT::Float":
        return _GRT.MixtureModel_getTrainingSigma(self)

    def getNullRejectionThreshold(self) -> "GRT::Float":
        return _GRT.MixtureModel_getNullRejectionThreshold(self)

    def getNormalizationFactor(self) -> "GRT::Float":
        return _GRT.MixtureModel_getNormalizationFactor(self)

    def setClassLabel(self, classLabel: 'UINT const') -> "bool":
        return _GRT.MixtureModel_setClassLabel(self, classLabel)

    def setNormalizationFactor(self, normFactor: 'GRT::Float const') -> "bool":
        return _GRT.MixtureModel_setNormalizationFactor(self, normFactor)

    def setTrainingMuAndSigma(self, trainingMu: 'GRT::Float const', trainingSigma: 'GRT::Float const') -> "bool":
        return _GRT.MixtureModel_setTrainingMuAndSigma(self, trainingMu, trainingSigma)

    def setNullRejectionThreshold(self, nullRejectionThreshold: 'GRT::Float const') -> "bool":
        return _GRT.MixtureModel_setNullRejectionThreshold(self, nullRejectionThreshold)
MixtureModel_swigregister = _GRT.MixtureModel_swigregister
MixtureModel_swigregister(MixtureModel)

GMM_MIN_SCALE_VALUE = _GRT.GMM_MIN_SCALE_VALUE
GMM_MAX_SCALE_VALUE = _GRT.GMM_MAX_SCALE_VALUE
class GMM(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_GMM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GMM
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.GMM_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.GMM_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.GMM_recomputeNullRejectionThresholds(self)

    def getNumMixtureModels(self) -> "UINT":
        return _GRT.GMM_getNumMixtureModels(self)

    def getModels(self) -> "GRT::Vector< GRT::MixtureModel >":
        return _GRT.GMM_getModels(self)

    def setNumMixtureModels(self, K: 'UINT const') -> "bool":
        return _GRT.GMM_setNumMixtureModels(self, K)

    def setMaxIter(self, maxIter: 'UINT') -> "bool":
        return _GRT.GMM_setMaxIter(self, maxIter)
    if _newclass:
        getId = staticmethod(_GRT.GMM_getId)
    else:
        getId = _GRT.GMM_getId

    def save(self, *args) -> "bool":
        return _GRT.GMM_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.GMM_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.GMM_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.GMM_predict_(self, *args)
GMM_swigregister = _GRT.GMM_swigregister
GMM_swigregister(GMM)

def GMM_getId() -> "std::string":
    return _GRT.GMM_getId()
GMM_getId = _GRT.GMM_getId

HMM_ERGODIC = _GRT.HMM_ERGODIC
HMM_LEFTRIGHT = _GRT.HMM_LEFTRIGHT
HMM_DISCRETE = _GRT.HMM_DISCRETE
HMM_CONTINUOUS = _GRT.HMM_CONTINUOUS
class ContinuousHiddenMarkovModel(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContinuousHiddenMarkovModel, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ContinuousHiddenMarkovModel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ContinuousHiddenMarkovModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ContinuousHiddenMarkovModel
    __del__ = lambda self: None

    def predict_(self, *args) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_predict_(self, *args)

    def reset(self) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_reset(self)

    def clear(self) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_clear(self)

    def _print(self) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel__print(self)

    def getNumStates(self) -> "UINT":
        return _GRT.ContinuousHiddenMarkovModel_getNumStates(self)

    def getClassLabel(self) -> "UINT":
        return _GRT.ContinuousHiddenMarkovModel_getClassLabel(self)

    def getLoglikelihood(self) -> "GRT::Float":
        return _GRT.ContinuousHiddenMarkovModel_getLoglikelihood(self)

    def getPhase(self) -> "GRT::Float":
        return _GRT.ContinuousHiddenMarkovModel_getPhase(self)

    def getEstimatedStates(self) -> "GRT::Vector< UINT >":
        return _GRT.ContinuousHiddenMarkovModel_getEstimatedStates(self)

    def getAlpha(self) -> "GRT::MatrixFloat":
        return _GRT.ContinuousHiddenMarkovModel_getAlpha(self)

    def setDownsampleFactor(self, downsampleFactor: 'UINT const') -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_setDownsampleFactor(self, downsampleFactor)

    def setModelType(self, modelType: 'UINT const') -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_setModelType(self, modelType)

    def setDelta(self, delta: 'UINT const') -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_setDelta(self, delta)

    def setSigma(self, sigma: 'GRT::Float const') -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_setSigma(self, sigma)

    def setAutoEstimateSigma(self, autoEstimateSigma: 'bool const') -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_setAutoEstimateSigma(self, autoEstimateSigma)

    def save(self, *args) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_train_(self, *args)
ContinuousHiddenMarkovModel_swigregister = _GRT.ContinuousHiddenMarkovModel_swigregister
ContinuousHiddenMarkovModel_swigregister(ContinuousHiddenMarkovModel)

class HMMTrainingObject(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMMTrainingObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HMMTrainingObject, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_HMMTrainingObject()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_HMMTrainingObject
    __del__ = lambda self: None
    __swig_setmethods__["alpha"] = _GRT.HMMTrainingObject_alpha_set
    __swig_getmethods__["alpha"] = _GRT.HMMTrainingObject_alpha_get
    if _newclass:
        alpha = _swig_property(_GRT.HMMTrainingObject_alpha_get, _GRT.HMMTrainingObject_alpha_set)
    __swig_setmethods__["beta"] = _GRT.HMMTrainingObject_beta_set
    __swig_getmethods__["beta"] = _GRT.HMMTrainingObject_beta_get
    if _newclass:
        beta = _swig_property(_GRT.HMMTrainingObject_beta_get, _GRT.HMMTrainingObject_beta_set)
    __swig_setmethods__["c"] = _GRT.HMMTrainingObject_c_set
    __swig_getmethods__["c"] = _GRT.HMMTrainingObject_c_get
    if _newclass:
        c = _swig_property(_GRT.HMMTrainingObject_c_get, _GRT.HMMTrainingObject_c_set)
    __swig_setmethods__["pk"] = _GRT.HMMTrainingObject_pk_set
    __swig_getmethods__["pk"] = _GRT.HMMTrainingObject_pk_get
    if _newclass:
        pk = _swig_property(_GRT.HMMTrainingObject_pk_get, _GRT.HMMTrainingObject_pk_set)
HMMTrainingObject_swigregister = _GRT.HMMTrainingObject_swigregister
HMMTrainingObject_swigregister(HMMTrainingObject)

class DiscreteHiddenMarkovModel(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscreteHiddenMarkovModel, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscreteHiddenMarkovModel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_DiscreteHiddenMarkovModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DiscreteHiddenMarkovModel
    __del__ = lambda self: None

    def resetModel(self, numStates: 'UINT const', numSymbols: 'UINT const', modelType: 'UINT const', delta: 'UINT const') -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_resetModel(self, numStates, numSymbols, modelType, delta)

    def reset(self) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_reset(self)

    def randomizeMatrices(self, numStates: 'UINT const', numSymbols: 'UINT const') -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_randomizeMatrices(self, numStates, numSymbols)

    def predictLogLikelihood(self, obs: 'VectorTUINT') -> "GRT::Float":
        return _GRT.DiscreteHiddenMarkovModel_predictLogLikelihood(self, obs)

    def forwardBackward(self, trainingObject: 'HMMTrainingObject', obs: 'VectorTUINT') -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_forwardBackward(self, trainingObject, obs)

    def _print(self) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel__print(self)

    def getTrainingIterationLog(self) -> "GRT::VectorFloat":
        return _GRT.DiscreteHiddenMarkovModel_getTrainingIterationLog(self)

    def save(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_predict_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_predict(self, *args)
DiscreteHiddenMarkovModel_swigregister = _GRT.DiscreteHiddenMarkovModel_swigregister
DiscreteHiddenMarkovModel_swigregister(DiscreteHiddenMarkovModel)

class HMM(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HMM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_HMM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_HMM
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.HMM_deepCopyFrom(self, classifier)

    def predict_(self, *args) -> "bool":
        return _GRT.HMM_predict_(self, *args)

    def reset(self) -> "bool":
        return _GRT.HMM_reset(self)

    def clear(self) -> "bool":
        return _GRT.HMM_clear(self)

    def _print(self) -> "bool":
        return _GRT.HMM__print(self)

    def getHMMType(self) -> "UINT":
        return _GRT.HMM_getHMMType(self)

    def getModelType(self) -> "UINT":
        return _GRT.HMM_getModelType(self)

    def getDelta(self) -> "UINT":
        return _GRT.HMM_getDelta(self)

    def getNumStates(self) -> "UINT":
        return _GRT.HMM_getNumStates(self)

    def getNumSymbols(self) -> "UINT":
        return _GRT.HMM_getNumSymbols(self)

    def getNumRandomTrainingIterations(self) -> "UINT":
        return _GRT.HMM_getNumRandomTrainingIterations(self)

    def getDiscreteModels(self) -> "GRT::Vector< GRT::DiscreteHiddenMarkovModel >":
        return _GRT.HMM_getDiscreteModels(self)

    def getContinuousModels(self) -> "GRT::Vector< GRT::ContinuousHiddenMarkovModel >":
        return _GRT.HMM_getContinuousModels(self)

    def setHMMType(self, hmmType: 'UINT const') -> "bool":
        return _GRT.HMM_setHMMType(self, hmmType)

    def setModelType(self, modelType: 'UINT const') -> "bool":
        return _GRT.HMM_setModelType(self, modelType)

    def setDelta(self, delta: 'UINT const') -> "bool":
        return _GRT.HMM_setDelta(self, delta)

    def setDownsampleFactor(self, downsampleFactor: 'UINT const') -> "bool":
        return _GRT.HMM_setDownsampleFactor(self, downsampleFactor)

    def setCommitteeSize(self, committeeSize: 'UINT const') -> "bool":
        return _GRT.HMM_setCommitteeSize(self, committeeSize)

    def setNumStates(self, numStates: 'UINT const') -> "bool":
        return _GRT.HMM_setNumStates(self, numStates)

    def setNumSymbols(self, numStates: 'UINT const') -> "bool":
        return _GRT.HMM_setNumSymbols(self, numStates)

    def setNumRandomTrainingIterations(self, numRandomTrainingIterations: 'UINT const') -> "bool":
        return _GRT.HMM_setNumRandomTrainingIterations(self, numRandomTrainingIterations)

    def setSigma(self, sigma: 'GRT::Float const') -> "bool":
        return _GRT.HMM_setSigma(self, sigma)

    def setAutoEstimateSigma(self, autoEstimateSigma: 'bool const') -> "bool":
        return _GRT.HMM_setAutoEstimateSigma(self, autoEstimateSigma)
    if _newclass:
        getId = staticmethod(_GRT.HMM_getId)
    else:
        getId = _GRT.HMM_getId

    def save(self, *args) -> "bool":
        return _GRT.HMM_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.HMM_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.HMM_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.HMM_train_(self, *args)
HMM_swigregister = _GRT.HMM_swigregister
HMM_swigregister(HMM)

def HMM_getId() -> "std::string":
    return _GRT.HMM_getId()
HMM_getId = _GRT.HMM_getId

class MinDistModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinDistModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinDistModel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MinDistModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MinDistModel
    __del__ = lambda self: None

    def train(self, classLabel: 'UINT', trainingData: 'MatrixFloat', numClusters: 'UINT', minChange: 'GRT::Float', maxNumEpochs: 'UINT') -> "bool":
        return _GRT.MinDistModel_train(self, classLabel, trainingData, numClusters, minChange, maxNumEpochs)

    def predict(self, observation: 'VectorFloat') -> "GRT::Float":
        return _GRT.MinDistModel_predict(self, observation)

    def recomputeThresholdValue(self) -> "void":
        return _GRT.MinDistModel_recomputeThresholdValue(self)

    def getClassLabel(self) -> "UINT":
        return _GRT.MinDistModel_getClassLabel(self)

    def getNumFeatures(self) -> "UINT":
        return _GRT.MinDistModel_getNumFeatures(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.MinDistModel_getNumClusters(self)

    def getRejectionThreshold(self) -> "GRT::Float":
        return _GRT.MinDistModel_getRejectionThreshold(self)

    def getGamma(self) -> "GRT::Float":
        return _GRT.MinDistModel_getGamma(self)

    def getTrainingMu(self) -> "GRT::Float":
        return _GRT.MinDistModel_getTrainingMu(self)

    def getTrainingSigma(self) -> "GRT::Float":
        return _GRT.MinDistModel_getTrainingSigma(self)

    def getClusters(self) -> "GRT::MatrixFloat":
        return _GRT.MinDistModel_getClusters(self)

    def setClassLabel(self, classLabel: 'UINT') -> "bool":
        return _GRT.MinDistModel_setClassLabel(self, classLabel)

    def setClusters(self, clusters: 'MatrixFloat') -> "bool":
        return _GRT.MinDistModel_setClusters(self, clusters)

    def setGamma(self, gamma: 'GRT::Float') -> "bool":
        return _GRT.MinDistModel_setGamma(self, gamma)

    def setRejectionThreshold(self, rejectionThreshold: 'GRT::Float') -> "bool":
        return _GRT.MinDistModel_setRejectionThreshold(self, rejectionThreshold)

    def setTrainingSigma(self, trainingSigma: 'GRT::Float') -> "bool":
        return _GRT.MinDistModel_setTrainingSigma(self, trainingSigma)

    def setTrainingMu(self, trainingMu: 'GRT::Float') -> "bool":
        return _GRT.MinDistModel_setTrainingMu(self, trainingMu)

    def setTrainingLoggingEnabled(self, enabled: 'bool') -> "bool":
        return _GRT.MinDistModel_setTrainingLoggingEnabled(self, enabled)
MinDistModel_swigregister = _GRT.MinDistModel_swigregister
MinDistModel_swigregister(MinDistModel)

class MinDist(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinDist, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MinDist, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MinDist(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MinDist
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.MinDist_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.MinDist_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.MinDist_recomputeNullRejectionThresholds(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.MinDist_getNumClusters(self)

    def getModels(self) -> "GRT::Vector< GRT::MinDistModel >":
        return _GRT.MinDist_getModels(self)

    def setNullRejectionCoeff(self, nullRejectionCoeff: 'GRT::Float') -> "bool":
        return _GRT.MinDist_setNullRejectionCoeff(self, nullRejectionCoeff)

    def setNumClusters(self, numClusters: 'UINT') -> "bool":
        return _GRT.MinDist_setNumClusters(self, numClusters)
    if _newclass:
        getId = staticmethod(_GRT.MinDist_getId)
    else:
        getId = _GRT.MinDist_getId

    def save(self, *args) -> "bool":
        return _GRT.MinDist_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.MinDist_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.MinDist_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.MinDist_predict_(self, *args)
MinDist_swigregister = _GRT.MinDist_swigregister
MinDist_swigregister(MinDist)

def MinDist_getId() -> "std::string":
    return _GRT.MinDist_getId()
MinDist_getId = _GRT.MinDist_getId

class ParticleClassifierGestureTemplate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleClassifierGestureTemplate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleClassifierGestureTemplate, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_ParticleClassifierGestureTemplate()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ParticleClassifierGestureTemplate
    __del__ = lambda self: None

    def getLength(self) -> "unsigned int":
        return _GRT.ParticleClassifierGestureTemplate_getLength(self)
    __swig_setmethods__["classLabel"] = _GRT.ParticleClassifierGestureTemplate_classLabel_set
    __swig_getmethods__["classLabel"] = _GRT.ParticleClassifierGestureTemplate_classLabel_get
    if _newclass:
        classLabel = _swig_property(_GRT.ParticleClassifierGestureTemplate_classLabel_get, _GRT.ParticleClassifierGestureTemplate_classLabel_set)
    __swig_setmethods__["timeseries"] = _GRT.ParticleClassifierGestureTemplate_timeseries_set
    __swig_getmethods__["timeseries"] = _GRT.ParticleClassifierGestureTemplate_timeseries_get
    if _newclass:
        timeseries = _swig_property(_GRT.ParticleClassifierGestureTemplate_timeseries_get, _GRT.ParticleClassifierGestureTemplate_timeseries_set)
ParticleClassifierGestureTemplate_swigregister = _GRT.ParticleClassifierGestureTemplate_swigregister
ParticleClassifierGestureTemplate_swigregister(ParticleClassifierGestureTemplate)

class ParticleClassifierParticleFilter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleClassifierParticleFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleClassifierParticleFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_ParticleClassifierParticleFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ParticleClassifierParticleFilter
    __del__ = lambda self: None

    def preFilterUpdate(self, data: 'VectorFloat') -> "bool":
        return _GRT.ParticleClassifierParticleFilter_preFilterUpdate(self, data)

    def postFilterUpdate(self, data: 'VectorFloat') -> "bool":
        return _GRT.ParticleClassifierParticleFilter_postFilterUpdate(self, data)

    def predict(self, p: 'Particle &') -> "bool":
        return _GRT.ParticleClassifierParticleFilter_predict(self, p)

    def update(self, p: 'Particle &', data: 'VectorFloat') -> "bool":
        return _GRT.ParticleClassifierParticleFilter_update(self, p, data)

    def clear(self) -> "bool":
        return _GRT.ParticleClassifierParticleFilter_clear(self)

    def train(self, numParticles: 'unsigned int const', trainingData: 'TimeSeriesClassificationData', sensorNoise: 'GRT::Float', transitionSigma: 'GRT::Float', phaseSigma: 'GRT::Float', velocitySigma: 'GRT::Float') -> "bool":
        return _GRT.ParticleClassifierParticleFilter_train(self, numParticles, trainingData, sensorNoise, transitionSigma, phaseSigma, velocitySigma)
    __swig_setmethods__["numInputDimensions"] = _GRT.ParticleClassifierParticleFilter_numInputDimensions_set
    __swig_getmethods__["numInputDimensions"] = _GRT.ParticleClassifierParticleFilter_numInputDimensions_get
    if _newclass:
        numInputDimensions = _swig_property(_GRT.ParticleClassifierParticleFilter_numInputDimensions_get, _GRT.ParticleClassifierParticleFilter_numInputDimensions_set)
    __swig_setmethods__["numTemplates"] = _GRT.ParticleClassifierParticleFilter_numTemplates_set
    __swig_getmethods__["numTemplates"] = _GRT.ParticleClassifierParticleFilter_numTemplates_get
    if _newclass:
        numTemplates = _swig_property(_GRT.ParticleClassifierParticleFilter_numTemplates_get, _GRT.ParticleClassifierParticleFilter_numTemplates_set)
    __swig_setmethods__["numClasses"] = _GRT.ParticleClassifierParticleFilter_numClasses_set
    __swig_getmethods__["numClasses"] = _GRT.ParticleClassifierParticleFilter_numClasses_get
    if _newclass:
        numClasses = _swig_property(_GRT.ParticleClassifierParticleFilter_numClasses_get, _GRT.ParticleClassifierParticleFilter_numClasses_set)
    __swig_setmethods__["resampleCounter"] = _GRT.ParticleClassifierParticleFilter_resampleCounter_set
    __swig_getmethods__["resampleCounter"] = _GRT.ParticleClassifierParticleFilter_resampleCounter_get
    if _newclass:
        resampleCounter = _swig_property(_GRT.ParticleClassifierParticleFilter_resampleCounter_get, _GRT.ParticleClassifierParticleFilter_resampleCounter_set)
    __swig_setmethods__["gestureTemplates"] = _GRT.ParticleClassifierParticleFilter_gestureTemplates_set
    __swig_getmethods__["gestureTemplates"] = _GRT.ParticleClassifierParticleFilter_gestureTemplates_get
    if _newclass:
        gestureTemplates = _swig_property(_GRT.ParticleClassifierParticleFilter_gestureTemplates_get, _GRT.ParticleClassifierParticleFilter_gestureTemplates_set)
ParticleClassifierParticleFilter_swigregister = _GRT.ParticleClassifierParticleFilter_swigregister
ParticleClassifierParticleFilter_swigregister(ParticleClassifierParticleFilter)

class ParticleClassifier(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleClassifier, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleClassifier, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ParticleClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ParticleClassifier
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.ParticleClassifier_deepCopyFrom(self, classifier)

    def save(self, file: 'std::fstream &') -> "bool":
        return _GRT.ParticleClassifier_save(self, file)

    def load(self, file: 'std::fstream &') -> "bool":
        return _GRT.ParticleClassifier_load(self, file)

    def clear(self) -> "bool":
        return _GRT.ParticleClassifier_clear(self)

    def reset(self) -> "bool":
        return _GRT.ParticleClassifier_reset(self)
    if _newclass:
        getId = staticmethod(_GRT.ParticleClassifier_getId)
    else:
        getId = _GRT.ParticleClassifier_getId

    def getGestureTemplates(self) -> "GRT::Vector< GRT::ParticleClassifierGestureTemplate > const &":
        return _GRT.ParticleClassifier_getGestureTemplates(self)

    def getParticleFilter(self) -> "GRT::ParticleClassifierParticleFilter const &":
        return _GRT.ParticleClassifier_getParticleFilter(self)

    def getStateEstimation(self) -> "GRT::VectorFloat":
        return _GRT.ParticleClassifier_getStateEstimation(self)

    def getPhase(self) -> "GRT::Float":
        return _GRT.ParticleClassifier_getPhase(self)

    def getVelocity(self) -> "GRT::Float":
        return _GRT.ParticleClassifier_getVelocity(self)

    def setNumParticles(self, numParticles: 'unsigned int const') -> "bool":
        return _GRT.ParticleClassifier_setNumParticles(self, numParticles)

    def setSensorNoise(self, sensorNoise: 'unsigned int const') -> "bool":
        return _GRT.ParticleClassifier_setSensorNoise(self, sensorNoise)

    def setTransitionSigma(self, transitionSigma: 'unsigned int const') -> "bool":
        return _GRT.ParticleClassifier_setTransitionSigma(self, transitionSigma)

    def setPhaseSigma(self, phaseSigma: 'unsigned int const') -> "bool":
        return _GRT.ParticleClassifier_setPhaseSigma(self, phaseSigma)

    def setVelocitySigma(self, velocitySigma: 'unsigned int const') -> "bool":
        return _GRT.ParticleClassifier_setVelocitySigma(self, velocitySigma)

    def predict_(self, *args) -> "bool":
        return _GRT.ParticleClassifier_predict_(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.ParticleClassifier_train_(self, *args)
ParticleClassifier_swigregister = _GRT.ParticleClassifier_swigregister
ParticleClassifier_swigregister(ParticleClassifier)

def ParticleClassifier_getId() -> "std::string":
    return _GRT.ParticleClassifier_getId()
ParticleClassifier_getId = _GRT.ParticleClassifier_getId

class RandomForests(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RandomForests, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RandomForests, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_RandomForests(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_RandomForests
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.RandomForests_deepCopyFrom(self, classifier)

    def train_(self, trainingData: 'ClassificationData') -> "bool":
        return _GRT.RandomForests_train_(self, trainingData)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.RandomForests_predict_(self, inputVector)

    def clear(self) -> "bool":
        return _GRT.RandomForests_clear(self)

    def _print(self) -> "bool":
        return _GRT.RandomForests__print(self)

    def combineModels(self, forest: 'RandomForests') -> "bool":
        return _GRT.RandomForests_combineModels(self, forest)

    def getForestSize(self) -> "UINT":
        return _GRT.RandomForests_getForestSize(self)

    def getNumRandomSplits(self) -> "UINT":
        return _GRT.RandomForests_getNumRandomSplits(self)

    def getMinNumSamplesPerNode(self) -> "UINT":
        return _GRT.RandomForests_getMinNumSamplesPerNode(self)

    def getMaxDepth(self) -> "UINT":
        return _GRT.RandomForests_getMaxDepth(self)

    def getTrainingMode(self) -> "UINT":
        return _GRT.RandomForests_getTrainingMode(self)

    def getForest(self) -> "GRT::Vector< GRT::DecisionTreeNode * > const &":
        return _GRT.RandomForests_getForest(self)

    def getRemoveFeaturesAtEachSplit(self) -> "bool":
        return _GRT.RandomForests_getRemoveFeaturesAtEachSplit(self)

    def getBootstrappedDatasetWeight(self) -> "GRT::Float":
        return _GRT.RandomForests_getBootstrappedDatasetWeight(self)

    def getTree(self, index: 'UINT const') -> "GRT::DecisionTreeNode *":
        return _GRT.RandomForests_getTree(self, index)

    def deepCopyDecisionTreeNode(self) -> "GRT::DecisionTreeNode *":
        return _GRT.RandomForests_deepCopyDecisionTreeNode(self)

    def getFeatureWeights(self, normWeights: 'bool const'=True) -> "GRT::VectorDouble":
        return _GRT.RandomForests_getFeatureWeights(self, normWeights)

    def getLeafNodeFeatureWeights(self, normWeights: 'bool const'=True) -> "GRT::MatrixDouble":
        return _GRT.RandomForests_getLeafNodeFeatureWeights(self, normWeights)

    def setForestSize(self, forestSize: 'UINT const') -> "bool":
        return _GRT.RandomForests_setForestSize(self, forestSize)

    def setNumRandomSplits(self, numSplittingSteps: 'UINT const') -> "bool":
        return _GRT.RandomForests_setNumRandomSplits(self, numSplittingSteps)

    def setMinNumSamplesPerNode(self, minNumSamplesPerNode: 'UINT const') -> "bool":
        return _GRT.RandomForests_setMinNumSamplesPerNode(self, minNumSamplesPerNode)

    def setMaxDepth(self, maxDepth: 'UINT const') -> "bool":
        return _GRT.RandomForests_setMaxDepth(self, maxDepth)

    def setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit: 'bool const') -> "bool":
        return _GRT.RandomForests_setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit)

    def setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt: 'bool const') -> "bool":
        return _GRT.RandomForests_setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt)

    def setTrainingMode(self, trainingMode: 'Tree::TrainingMode const') -> "bool":
        return _GRT.RandomForests_setTrainingMode(self, trainingMode)

    def setDecisionTreeNode(self, node: 'DecisionTreeNode') -> "bool":
        return _GRT.RandomForests_setDecisionTreeNode(self, node)

    def setBootstrappedDatasetWeight(self, bootstrappedDatasetWeight: 'GRT::Float const') -> "bool":
        return _GRT.RandomForests_setBootstrappedDatasetWeight(self, bootstrappedDatasetWeight)
    if _newclass:
        getId = staticmethod(_GRT.RandomForests_getId)
    else:
        getId = _GRT.RandomForests_getId

    def save(self, *args) -> "bool":
        return _GRT.RandomForests_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.RandomForests_load(self, *args)
RandomForests_swigregister = _GRT.RandomForests_swigregister
RandomForests_swigregister(RandomForests)

def RandomForests_getId() -> "std::string":
    return _GRT.RandomForests_getId()
RandomForests_getId = _GRT.RandomForests_getId

class SoftmaxModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SoftmaxModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SoftmaxModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_SoftmaxModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_SoftmaxModel
    __del__ = lambda self: None

    def init(self, classLabel: 'UINT', N: 'UINT') -> "bool":
        return _GRT.SoftmaxModel_init(self, classLabel, N)

    def compute(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.SoftmaxModel_compute(self, x)
    __swig_setmethods__["classLabel"] = _GRT.SoftmaxModel_classLabel_set
    __swig_getmethods__["classLabel"] = _GRT.SoftmaxModel_classLabel_get
    if _newclass:
        classLabel = _swig_property(_GRT.SoftmaxModel_classLabel_get, _GRT.SoftmaxModel_classLabel_set)
    __swig_setmethods__["N"] = _GRT.SoftmaxModel_N_set
    __swig_getmethods__["N"] = _GRT.SoftmaxModel_N_get
    if _newclass:
        N = _swig_property(_GRT.SoftmaxModel_N_get, _GRT.SoftmaxModel_N_set)
    __swig_setmethods__["w"] = _GRT.SoftmaxModel_w_set
    __swig_getmethods__["w"] = _GRT.SoftmaxModel_w_get
    if _newclass:
        w = _swig_property(_GRT.SoftmaxModel_w_get, _GRT.SoftmaxModel_w_set)
    __swig_setmethods__["w0"] = _GRT.SoftmaxModel_w0_set
    __swig_getmethods__["w0"] = _GRT.SoftmaxModel_w0_get
    if _newclass:
        w0 = _swig_property(_GRT.SoftmaxModel_w0_get, _GRT.SoftmaxModel_w0_set)
SoftmaxModel_swigregister = _GRT.SoftmaxModel_swigregister
SoftmaxModel_swigregister(SoftmaxModel)

class Softmax(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Softmax, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Softmax, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_Softmax(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Softmax
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.Softmax_deepCopyFrom(self, classifier)

    def train_(self, trainingData: 'ClassificationData') -> "bool":
        return _GRT.Softmax_train_(self, trainingData)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.Softmax_predict_(self, inputVector)

    def clear(self) -> "bool":
        return _GRT.Softmax_clear(self)

    def getModels(self) -> "GRT::Vector< GRT::SoftmaxModel >":
        return _GRT.Softmax_getModels(self)
    if _newclass:
        getId = staticmethod(_GRT.Softmax_getId)
    else:
        getId = _GRT.Softmax_getId

    def save(self, *args) -> "bool":
        return _GRT.Softmax_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.Softmax_load(self, *args)
Softmax_swigregister = _GRT.Softmax_swigregister
Softmax_swigregister(Softmax)

def Softmax_getId() -> "std::string":
    return _GRT.Softmax_getId()
Softmax_getId = _GRT.Softmax_getId

SVM_MIN_SCALE_RANGE = _GRT.SVM_MIN_SCALE_RANGE
SVM_MAX_SCALE_RANGE = _GRT.SVM_MAX_SCALE_RANGE
class SVM(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVM, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SVM, name)
    __repr__ = _swig_repr
    C_SVC = _GRT.SVM_C_SVC
    NU_SVC = _GRT.SVM_NU_SVC
    ONE_CLASS = _GRT.SVM_ONE_CLASS
    EPSILON_SVR = _GRT.SVM_EPSILON_SVR
    NU_SVR = _GRT.SVM_NU_SVR
    NUM_SVM_TYPES = _GRT.SVM_NUM_SVM_TYPES
    LINEAR_KERNEL = _GRT.SVM_LINEAR_KERNEL
    POLY_KERNEL = _GRT.SVM_POLY_KERNEL
    RBF_KERNEL = _GRT.SVM_RBF_KERNEL
    SIGMOID_KERNEL = _GRT.SVM_SIGMOID_KERNEL
    PRECOMPUTED_KERNEL = _GRT.SVM_PRECOMPUTED_KERNEL
    NUM_KERNEL_TYPES = _GRT.SVM_NUM_KERNEL_TYPES

    def __init__(self, *args):
        this = _GRT.new_SVM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_SVM
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.SVM_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.SVM_clear(self)

    def init(self, kernelType: 'GRT::SVM::KernelType', svmType: 'GRT::SVM::SVMType', useScaling: 'bool', useNullRejection: 'bool', useAutoGamma: 'bool', gamma: 'GRT::Float', degree: 'UINT', coef0: 'GRT::Float', nu: 'GRT::Float', C: 'GRT::Float', useCrossValidation: 'bool', kFoldValue: 'UINT') -> "bool":
        return _GRT.SVM_init(self, kernelType, svmType, useScaling, useNullRejection, useAutoGamma, gamma, degree, coef0, nu, C, useCrossValidation, kFoldValue)

    def initDefaultSVMSettings(self) -> "void":
        return _GRT.SVM_initDefaultSVMSettings(self)

    def getIsCrossValidationTrainingEnabled(self) -> "bool":
        return _GRT.SVM_getIsCrossValidationTrainingEnabled(self)

    def getIsAutoGammaEnabled(self) -> "bool":
        return _GRT.SVM_getIsAutoGammaEnabled(self)

    def getSVMType(self) -> "std::string":
        return _GRT.SVM_getSVMType(self)

    def getKernelType(self) -> "std::string":
        return _GRT.SVM_getKernelType(self)

    def getDegree(self) -> "UINT":
        return _GRT.SVM_getDegree(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.SVM_getNumClasses(self)

    def getGamma(self) -> "GRT::Float":
        return _GRT.SVM_getGamma(self)

    def getNu(self) -> "GRT::Float":
        return _GRT.SVM_getNu(self)

    def getCoef0(self) -> "GRT::Float":
        return _GRT.SVM_getCoef0(self)

    def getC(self) -> "GRT::Float":
        return _GRT.SVM_getC(self)

    def getCrossValidationResult(self) -> "GRT::Float":
        return _GRT.SVM_getCrossValidationResult(self)

    def getLIBSVMModel(self) -> "LIBSVM::svm_model const *":
        return _GRT.SVM_getLIBSVMModel(self)

    def setSVMType(self, svmType: 'GRT::SVM::SVMType const') -> "bool":
        return _GRT.SVM_setSVMType(self, svmType)

    def setKernelType(self, kernelType: 'GRT::SVM::KernelType const') -> "bool":
        return _GRT.SVM_setKernelType(self, kernelType)

    def setGamma(self, gamma: 'GRT::Float const') -> "bool":
        return _GRT.SVM_setGamma(self, gamma)

    def setDegree(self, degree: 'UINT const') -> "bool":
        return _GRT.SVM_setDegree(self, degree)

    def setNu(self, nu: 'GRT::Float const') -> "bool":
        return _GRT.SVM_setNu(self, nu)

    def setCoef0(self, coef0: 'GRT::Float const') -> "bool":
        return _GRT.SVM_setCoef0(self, coef0)

    def setC(self, C: 'GRT::Float const') -> "bool":
        return _GRT.SVM_setC(self, C)

    def setKFoldCrossValidationValue(self, kFoldValue: 'UINT const') -> "bool":
        return _GRT.SVM_setKFoldCrossValidationValue(self, kFoldValue)

    def enableAutoGamma(self, useAutoGamma: 'bool const') -> "bool":
        return _GRT.SVM_enableAutoGamma(self, useAutoGamma)

    def enableCrossValidationTraining(self, useCrossValidation: 'bool const') -> "bool":
        return _GRT.SVM_enableCrossValidationTraining(self, useCrossValidation)
    if _newclass:
        getId = staticmethod(_GRT.SVM_getId)
    else:
        getId = _GRT.SVM_getId

    def save(self, *args) -> "bool":
        return _GRT.SVM_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.SVM_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.SVM_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.SVM_predict_(self, *args)
SVM_swigregister = _GRT.SVM_swigregister
SVM_swigregister(SVM)

def SVM_getId() -> "std::string":
    return _GRT.SVM_getId()
SVM_getId = _GRT.SVM_getId

class SwipeDetector(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwipeDetector, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SwipeDetector, name)
    __repr__ = _swig_repr
    POSITIVE_SWIPE = _GRT.SwipeDetector_POSITIVE_SWIPE
    NEGATIVE_SWIPE = _GRT.SwipeDetector_NEGATIVE_SWIPE

    def __init__(self, *args):
        this = _GRT.new_SwipeDetector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_SwipeDetector
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.SwipeDetector_deepCopyFrom(self, classifier)

    def init(self, numInputDimensions: 'unsigned int const') -> "bool":
        return _GRT.SwipeDetector_init(self, numInputDimensions)

    def clear(self) -> "bool":
        return _GRT.SwipeDetector_clear(self)

    def reset(self) -> "bool":
        return _GRT.SwipeDetector_reset(self)

    def getSwipeDetected(self) -> "bool":
        return _GRT.SwipeDetector_getSwipeDetected(self)

    def getSwipeValue(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getSwipeValue(self)

    def getSwipeThreshold(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getSwipeThreshold(self)

    def getHysteresisThreshold(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getHysteresisThreshold(self)

    def getMovementVelocity(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getMovementVelocity(self)

    def getMovementThreshold(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getMovementThreshold(self)

    def getContextValue(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getContextValue(self)

    def getSwipeIntegrationCoeff(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getSwipeIntegrationCoeff(self)

    def setContext(self, context: 'bool const') -> "bool":
        return _GRT.SwipeDetector_setContext(self, context)

    def setSwipeIndex(self, swipeIndex: 'unsigned int const') -> "bool":
        return _GRT.SwipeDetector_setSwipeIndex(self, swipeIndex)

    def setSwipeDirection(self, swipeDirection: 'unsigned int const') -> "bool":
        return _GRT.SwipeDetector_setSwipeDirection(self, swipeDirection)

    def setSwipeThreshold(self, swipeThreshold: 'GRT::Float const') -> "bool":
        return _GRT.SwipeDetector_setSwipeThreshold(self, swipeThreshold)

    def setHysteresisThreshold(self, hysteresisThreshold: 'GRT::Float const') -> "bool":
        return _GRT.SwipeDetector_setHysteresisThreshold(self, hysteresisThreshold)

    def setMovementThreshold(self, movementThreshold: 'GRT::Float const') -> "bool":
        return _GRT.SwipeDetector_setMovementThreshold(self, movementThreshold)

    def setSwipeIntegrationCoeff(self, swipeIntegrationCoeff: 'GRT::Float const') -> "bool":
        return _GRT.SwipeDetector_setSwipeIntegrationCoeff(self, swipeIntegrationCoeff)
    if _newclass:
        getId = staticmethod(_GRT.SwipeDetector_getId)
    else:
        getId = _GRT.SwipeDetector_getId

    def save(self, *args) -> "bool":
        return _GRT.SwipeDetector_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.SwipeDetector_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.SwipeDetector_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.SwipeDetector_predict_(self, *args)
SwipeDetector_swigregister = _GRT.SwipeDetector_swigregister
SwipeDetector_swigregister(SwipeDetector)

def SwipeDetector_getId() -> "std::string":
    return _GRT.SwipeDetector_getId()
SwipeDetector_getId = _GRT.SwipeDetector_getId

class Clusterer(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Clusterer, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Clusterer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_Clusterer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Clusterer
    __del__ = lambda self: None

    def deepCopyFrom(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.Clusterer_deepCopyFrom(self, clusterer)

    def copyBaseVariables(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.Clusterer_copyBaseVariables(self, clusterer)

    def train_(self, *args) -> "bool":
        return _GRT.Clusterer_train_(self, *args)

    def reset(self) -> "bool":
        return _GRT.Clusterer_reset(self)

    def clear(self) -> "bool":
        return _GRT.Clusterer_clear(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.Clusterer_getNumClusters(self)

    def getPredictedClusterLabel(self) -> "UINT":
        return _GRT.Clusterer_getPredictedClusterLabel(self)

    def getMaximumLikelihood(self) -> "GRT::Float":
        return _GRT.Clusterer_getMaximumLikelihood(self)

    def getBestDistance(self) -> "GRT::Float":
        return _GRT.Clusterer_getBestDistance(self)

    def getClusterLikelihoods(self) -> "GRT::VectorFloat":
        return _GRT.Clusterer_getClusterLikelihoods(self)

    def getClusterDistances(self) -> "GRT::VectorFloat":
        return _GRT.Clusterer_getClusterDistances(self)

    def getClusterLabels(self) -> "GRT::Vector< UINT >":
        return _GRT.Clusterer_getClusterLabels(self)

    def getClustererType(self) -> "std::string":
        return _GRT.Clusterer_getClustererType(self)

    def setNumClusters(self, numClusters: 'UINT const') -> "bool":
        return _GRT.Clusterer_setNumClusters(self, numClusters)

    def create(self, *args) -> "GRT::Clusterer *":
        return _GRT.Clusterer_create(self, *args)

    def createNewInstance(self) -> "GRT::Clusterer *":
        return _GRT.Clusterer_createNewInstance(self)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.Clusterer_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.Clusterer_createInstanceFromString

    def deepCopy(self) -> "GRT::Clusterer *":
        return _GRT.Clusterer_deepCopy(self)

    def getBaseClusterer(self) -> "GRT::Clusterer const &":
        return _GRT.Clusterer_getBaseClusterer(self)
    if _newclass:
        getRegisteredClusterers = staticmethod(_GRT.Clusterer_getRegisteredClusterers)
    else:
        getRegisteredClusterers = _GRT.Clusterer_getRegisteredClusterers

    def train(self, *args) -> "bool":
        return _GRT.Clusterer_train(self, *args)
Clusterer_swigregister = _GRT.Clusterer_swigregister
Clusterer_swigregister(Clusterer)

def Clusterer_createInstanceFromString(id: 'std::string const &') -> "GRT::Clusterer *":
    return _GRT.Clusterer_createInstanceFromString(id)
Clusterer_createInstanceFromString = _GRT.Clusterer_createInstanceFromString

def Clusterer_getRegisteredClusterers() -> "GRT::Vector< std::string >":
    return _GRT.Clusterer_getRegisteredClusterers()
Clusterer_getRegisteredClusterers = _GRT.Clusterer_getRegisteredClusterers

class ClusterTreeNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClusterTreeNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClusterTreeNode, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_ClusterTreeNode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClusterTreeNode
    __del__ = lambda self: None

    def predict_(self, *args) -> "bool":
        return _GRT.ClusterTreeNode_predict_(self, *args)

    def clear(self) -> "bool":
        return _GRT.ClusterTreeNode_clear(self)

    def _print(self) -> "bool":
        return _GRT.ClusterTreeNode__print(self)

    def deepCopy(self) -> "Node *":
        return _GRT.ClusterTreeNode_deepCopy(self)

    def deepCopyTree(self) -> "GRT::ClusterTreeNode *":
        return _GRT.ClusterTreeNode_deepCopyTree(self)

    def getNodeSize(self) -> "UINT":
        return _GRT.ClusterTreeNode_getNodeSize(self)

    def getFeatureIndex(self) -> "UINT":
        return _GRT.ClusterTreeNode_getFeatureIndex(self)

    def getThreshold(self) -> "GRT::Float":
        return _GRT.ClusterTreeNode_getThreshold(self)

    def getClusterLabel(self) -> "UINT":
        return _GRT.ClusterTreeNode_getClusterLabel(self)

    def set(self, nodeSize: 'UINT const', featureIndex: 'UINT const', threshold: 'GRT::Float const', clusterLabel: 'UINT const') -> "bool":
        return _GRT.ClusterTreeNode_set(self, nodeSize, featureIndex, threshold, clusterLabel)
ClusterTreeNode_swigregister = _GRT.ClusterTreeNode_swigregister
ClusterTreeNode_swigregister(ClusterTreeNode)

class ClusterTree(Clusterer):
    __swig_setmethods__ = {}
    for _s in [Clusterer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClusterTree, name, value)
    __swig_getmethods__ = {}
    for _s in [Clusterer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClusterTree, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClusterTree(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClusterTree
    __del__ = lambda self: None

    def deepCopyFrom(self, cluster: 'Clusterer') -> "bool":
        return _GRT.ClusterTree_deepCopyFrom(self, cluster)

    def train_(self, trainingData: 'MatrixFloat') -> "bool":
        return _GRT.ClusterTree_train_(self, trainingData)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.ClusterTree_predict_(self, inputVector)

    def clear(self) -> "bool":
        return _GRT.ClusterTree_clear(self)

    def _print(self) -> "bool":
        return _GRT.ClusterTree__print(self)

    def deepCopyTree(self) -> "GRT::ClusterTreeNode *":
        return _GRT.ClusterTree_deepCopyTree(self)

    def getTree(self) -> "GRT::ClusterTreeNode const *":
        return _GRT.ClusterTree_getTree(self)

    def getPredictedClusterLabel(self) -> "UINT":
        return _GRT.ClusterTree_getPredictedClusterLabel(self)

    def getMinRMSErrorPerNode(self) -> "GRT::Float":
        return _GRT.ClusterTree_getMinRMSErrorPerNode(self)

    def getTrainingMode(self) -> "Tree::TrainingMode":
        return _GRT.ClusterTree_getTrainingMode(self)

    def getNumSplittingSteps(self) -> "UINT":
        return _GRT.ClusterTree_getNumSplittingSteps(self)

    def getMinNumSamplesPerNode(self) -> "UINT":
        return _GRT.ClusterTree_getMinNumSamplesPerNode(self)

    def getMaxDepth(self) -> "UINT":
        return _GRT.ClusterTree_getMaxDepth(self)

    def getPredictedNodeID(self) -> "UINT":
        return _GRT.ClusterTree_getPredictedNodeID(self)

    def getRemoveFeaturesAtEachSplit(self) -> "bool":
        return _GRT.ClusterTree_getRemoveFeaturesAtEachSplit(self)

    def setTrainingMode(self, trainingMode: 'Tree::TrainingMode const') -> "bool":
        return _GRT.ClusterTree_setTrainingMode(self, trainingMode)

    def setNumSplittingSteps(self, numSplittingSteps: 'UINT const') -> "bool":
        return _GRT.ClusterTree_setNumSplittingSteps(self, numSplittingSteps)

    def setMinNumSamplesPerNode(self, minNumSamplesPerNode: 'UINT const') -> "bool":
        return _GRT.ClusterTree_setMinNumSamplesPerNode(self, minNumSamplesPerNode)

    def setMaxDepth(self, maxDepth: 'UINT const') -> "bool":
        return _GRT.ClusterTree_setMaxDepth(self, maxDepth)

    def setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit: 'bool const') -> "bool":
        return _GRT.ClusterTree_setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit)

    def setMinRMSErrorPerNode(self, minRMSErrorPerNode: 'GRT::Float const') -> "bool":
        return _GRT.ClusterTree_setMinRMSErrorPerNode(self, minRMSErrorPerNode)

    def saveModelToFile(self, *args) -> "bool":
        return _GRT.ClusterTree_saveModelToFile(self, *args)

    def loadModelFromFile(self, *args) -> "bool":
        return _GRT.ClusterTree_loadModelFromFile(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.ClusterTree_train(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.ClusterTree_predict(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.ClusterTree_getId)
    else:
        getId = _GRT.ClusterTree_getId
ClusterTree_swigregister = _GRT.ClusterTree_swigregister
ClusterTree_swigregister(ClusterTree)

def ClusterTree_getId() -> "std::string":
    return _GRT.ClusterTree_getId()
ClusterTree_getId = _GRT.ClusterTree_getId

class GaussianMixtureModels(Clusterer):
    __swig_setmethods__ = {}
    for _s in [Clusterer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussianMixtureModels, name, value)
    __swig_getmethods__ = {}
    for _s in [Clusterer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GaussianMixtureModels, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_GaussianMixtureModels(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GaussianMixtureModels
    __del__ = lambda self: None

    def deepCopyFrom(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.GaussianMixtureModels_deepCopyFrom(self, clusterer)

    def reset(self) -> "bool":
        return _GRT.GaussianMixtureModels_reset(self)

    def clear(self) -> "bool":
        return _GRT.GaussianMixtureModels_clear(self)

    def train_(self, *args) -> "bool":
        return _GRT.GaussianMixtureModels_train_(self, *args)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.GaussianMixtureModels_predict_(self, inputVector)

    def getMu(self) -> "GRT::MatrixFloat":
        return _GRT.GaussianMixtureModels_getMu(self)

    def getSigma(self, *args) -> "GRT::MatrixFloat":
        return _GRT.GaussianMixtureModels_getSigma(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.GaussianMixtureModels_getId)
    else:
        getId = _GRT.GaussianMixtureModels_getId

    def setNumRestarts(self, numRestarts: 'UINT const') -> "bool":
        return _GRT.GaussianMixtureModels_setNumRestarts(self, numRestarts)

    def saveModelToFile(self, *args) -> "bool":
        return _GRT.GaussianMixtureModels_saveModelToFile(self, *args)

    def loadModelFromFile(self, *args) -> "bool":
        return _GRT.GaussianMixtureModels_loadModelFromFile(self, *args)
GaussianMixtureModels_swigregister = _GRT.GaussianMixtureModels_swigregister
GaussianMixtureModels_swigregister(GaussianMixtureModels)

def GaussianMixtureModels_getId() -> "std::string":
    return _GRT.GaussianMixtureModels_getId()
GaussianMixtureModels_getId = _GRT.GaussianMixtureModels_getId

class ClusterInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClusterInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClusterInfo, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClusterInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClusterInfo
    __del__ = lambda self: None

    def addSampleToCluster(self, i: 'UINT') -> "void":
        return _GRT.ClusterInfo_addSampleToCluster(self, i)

    def getUniqueClusterID(self) -> "UINT":
        return _GRT.ClusterInfo_getUniqueClusterID(self)

    def getNumSamplesInCluster(self) -> "UINT":
        return _GRT.ClusterInfo_getNumSamplesInCluster(self)

    def getClusterVariance(self) -> "GRT::Float":
        return _GRT.ClusterInfo_getClusterVariance(self)
    __swig_setmethods__["uniqueClusterID"] = _GRT.ClusterInfo_uniqueClusterID_set
    __swig_getmethods__["uniqueClusterID"] = _GRT.ClusterInfo_uniqueClusterID_get
    if _newclass:
        uniqueClusterID = _swig_property(_GRT.ClusterInfo_uniqueClusterID_get, _GRT.ClusterInfo_uniqueClusterID_set)
    __swig_setmethods__["clusterVariance"] = _GRT.ClusterInfo_clusterVariance_set
    __swig_getmethods__["clusterVariance"] = _GRT.ClusterInfo_clusterVariance_get
    if _newclass:
        clusterVariance = _swig_property(_GRT.ClusterInfo_clusterVariance_get, _GRT.ClusterInfo_clusterVariance_set)
    __swig_setmethods__["indexs"] = _GRT.ClusterInfo_indexs_set
    __swig_getmethods__["indexs"] = _GRT.ClusterInfo_indexs_get
    if _newclass:
        indexs = _swig_property(_GRT.ClusterInfo_indexs_get, _GRT.ClusterInfo_indexs_set)
ClusterInfo_swigregister = _GRT.ClusterInfo_swigregister
ClusterInfo_swigregister(ClusterInfo)

class ClusterLevel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClusterLevel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClusterLevel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClusterLevel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClusterLevel
    __del__ = lambda self: None

    def getLevel(self) -> "UINT":
        return _GRT.ClusterLevel_getLevel(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.ClusterLevel_getNumClusters(self)
    __swig_setmethods__["level"] = _GRT.ClusterLevel_level_set
    __swig_getmethods__["level"] = _GRT.ClusterLevel_level_get
    if _newclass:
        level = _swig_property(_GRT.ClusterLevel_level_get, _GRT.ClusterLevel_level_set)
    __swig_setmethods__["clusters"] = _GRT.ClusterLevel_clusters_set
    __swig_getmethods__["clusters"] = _GRT.ClusterLevel_clusters_get
    if _newclass:
        clusters = _swig_property(_GRT.ClusterLevel_clusters_get, _GRT.ClusterLevel_clusters_set)
ClusterLevel_swigregister = _GRT.ClusterLevel_swigregister
ClusterLevel_swigregister(ClusterLevel)

class HierarchicalClustering(Clusterer):
    __swig_setmethods__ = {}
    for _s in [Clusterer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HierarchicalClustering, name, value)
    __swig_getmethods__ = {}
    for _s in [Clusterer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HierarchicalClustering, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_HierarchicalClustering(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_HierarchicalClustering
    __del__ = lambda self: None

    def deepCopyFrom(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.HierarchicalClustering_deepCopyFrom(self, clusterer)

    def reset(self) -> "bool":
        return _GRT.HierarchicalClustering_reset(self)

    def clear(self) -> "bool":
        return _GRT.HierarchicalClustering_clear(self)

    def train_(self, *args) -> "bool":
        return _GRT.HierarchicalClustering_train_(self, *args)

    def printModel(self) -> "bool":
        return _GRT.HierarchicalClustering_printModel(self)

    def getClusters(self) -> "GRT::Vector< GRT::ClusterLevel >":
        return _GRT.HierarchicalClustering_getClusters(self)

    def saveModelToFile(self, *args) -> "bool":
        return _GRT.HierarchicalClustering_saveModelToFile(self, *args)

    def loadModelFromFile(self, *args) -> "bool":
        return _GRT.HierarchicalClustering_loadModelFromFile(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.HierarchicalClustering_getId)
    else:
        getId = _GRT.HierarchicalClustering_getId
HierarchicalClustering_swigregister = _GRT.HierarchicalClustering_swigregister
HierarchicalClustering_swigregister(HierarchicalClustering)

def HierarchicalClustering_getId() -> "std::string":
    return _GRT.HierarchicalClustering_getId()
HierarchicalClustering_getId = _GRT.HierarchicalClustering_getId

class KMeans(Clusterer):
    __swig_setmethods__ = {}
    for _s in [Clusterer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KMeans, name, value)
    __swig_getmethods__ = {}
    for _s in [Clusterer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KMeans, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_KMeans(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_KMeans
    __del__ = lambda self: None

    def deepCopyFrom(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.KMeans_deepCopyFrom(self, clusterer)

    def reset(self) -> "bool":
        return _GRT.KMeans_reset(self)

    def clear(self) -> "bool":
        return _GRT.KMeans_clear(self)

    def trainModel(self, data: 'MatrixFloat') -> "bool":
        return _GRT.KMeans_trainModel(self, data)

    def getTheta(self) -> "GRT::Float":
        return _GRT.KMeans_getTheta(self)

    def getModelTrained(self) -> "bool":
        return _GRT.KMeans_getModelTrained(self)

    def getTrainingThetaLog(self) -> "GRT::VectorFloat const &":
        return _GRT.KMeans_getTrainingThetaLog(self)

    def getClusters(self) -> "GRT::MatrixFloat const &":
        return _GRT.KMeans_getClusters(self)

    def getClassLabelsVector(self) -> "GRT::Vector< UINT > const &":
        return _GRT.KMeans_getClassLabelsVector(self)

    def getClassCountVector(self) -> "GRT::Vector< UINT > const &":
        return _GRT.KMeans_getClassCountVector(self)

    def setComputeTheta(self, computeTheta: 'bool const') -> "bool":
        return _GRT.KMeans_setComputeTheta(self, computeTheta)

    def setClusters(self, clusters: 'MatrixFloat') -> "bool":
        return _GRT.KMeans_setClusters(self, clusters)

    def saveModelToFile(self, *args) -> "bool":
        return _GRT.KMeans_saveModelToFile(self, *args)

    def loadModelFromFile(self, *args) -> "bool":
        return _GRT.KMeans_loadModelFromFile(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.KMeans_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.KMeans_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.KMeans_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.KMeans_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.KMeans_getId)
    else:
        getId = _GRT.KMeans_getId
KMeans_swigregister = _GRT.KMeans_swigregister
KMeans_swigregister(KMeans)

def KMeans_getId() -> "std::string":
    return _GRT.KMeans_getId()
KMeans_getId = _GRT.KMeans_getId

class GaussNeuron(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussNeuron, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GaussNeuron, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_GaussNeuron()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GaussNeuron
    __del__ = lambda self: None

    def init(self, numInputs: 'UINT const', sigma: 'GRT::Float const'=2.0, minWeightRange: 'GRT::Float const'=-1.0, maxWeightRange: 'GRT::Float const'=1.0) -> "bool":
        return _GRT.GaussNeuron_init(self, numInputs, sigma, minWeightRange, maxWeightRange)

    def clear(self) -> "bool":
        return _GRT.GaussNeuron_clear(self)

    def getInitialized(self) -> "bool":
        return _GRT.GaussNeuron_getInitialized(self)

    def getWeightDistance(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.GaussNeuron_getWeightDistance(self, x)

    def getSquaredWeightDistance(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.GaussNeuron_getSquaredWeightDistance(self, x)

    def fire(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.GaussNeuron_fire(self, x)

    def save(self, file: 'std::fstream &') -> "bool":
        return _GRT.GaussNeuron_save(self, file)

    def load(self, file: 'std::fstream &') -> "bool":
        return _GRT.GaussNeuron_load(self, file)
    __swig_setmethods__["numInputs"] = _GRT.GaussNeuron_numInputs_set
    __swig_getmethods__["numInputs"] = _GRT.GaussNeuron_numInputs_get
    if _newclass:
        numInputs = _swig_property(_GRT.GaussNeuron_numInputs_get, _GRT.GaussNeuron_numInputs_set)
    __swig_setmethods__["weights"] = _GRT.GaussNeuron_weights_set
    __swig_getmethods__["weights"] = _GRT.GaussNeuron_weights_get
    if _newclass:
        weights = _swig_property(_GRT.GaussNeuron_weights_get, _GRT.GaussNeuron_weights_set)
    __swig_setmethods__["sigma"] = _GRT.GaussNeuron_sigma_set
    __swig_getmethods__["sigma"] = _GRT.GaussNeuron_sigma_get
    if _newclass:
        sigma = _swig_property(_GRT.GaussNeuron_sigma_get, _GRT.GaussNeuron_sigma_set)
    __swig_setmethods__["initialized"] = _GRT.GaussNeuron_initialized_set
    __swig_getmethods__["initialized"] = _GRT.GaussNeuron_initialized_get
    if _newclass:
        initialized = _swig_property(_GRT.GaussNeuron_initialized_get, _GRT.GaussNeuron_initialized_set)
GaussNeuron_swigregister = _GRT.GaussNeuron_swigregister
GaussNeuron_swigregister(GaussNeuron)

class SelfOrganizingMap(Clusterer):
    __swig_setmethods__ = {}
    for _s in [Clusterer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SelfOrganizingMap, name, value)
    __swig_getmethods__ = {}
    for _s in [Clusterer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SelfOrganizingMap, name)
    __repr__ = _swig_repr
    RANDOM_NETWORK = _GRT.SelfOrganizingMap_RANDOM_NETWORK

    def __init__(self, *args):
        this = _GRT.new_SelfOrganizingMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_SelfOrganizingMap
    __del__ = lambda self: None

    def deepCopyFrom(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.SelfOrganizingMap_deepCopyFrom(self, clusterer)

    def reset(self) -> "bool":
        return _GRT.SelfOrganizingMap_reset(self)

    def clear(self) -> "bool":
        return _GRT.SelfOrganizingMap_clear(self)

    def train_(self, *args) -> "bool":
        return _GRT.SelfOrganizingMap_train_(self, *args)

    def map_(self, x: 'VectorFloat') -> "bool":
        return _GRT.SelfOrganizingMap_map_(self, x)

    def validateNetworkTypology(self, networkTypology: 'UINT const') -> "bool":
        return _GRT.SelfOrganizingMap_validateNetworkTypology(self, networkTypology)

    def getNetworkSize(self) -> "UINT":
        return _GRT.SelfOrganizingMap_getNetworkSize(self)

    def getAlphaStart(self) -> "GRT::Float":
        return _GRT.SelfOrganizingMap_getAlphaStart(self)

    def getAlphaEnd(self) -> "GRT::Float":
        return _GRT.SelfOrganizingMap_getAlphaEnd(self)

    def getMappedData(self) -> "GRT::VectorFloat":
        return _GRT.SelfOrganizingMap_getMappedData(self)

    def getNeurons(self) -> "GRT::Matrix< GRT::GaussNeuron >":
        return _GRT.SelfOrganizingMap_getNeurons(self)

    def getNeuronsRef(self) -> "GRT::Matrix< GRT::GaussNeuron > const &":
        return _GRT.SelfOrganizingMap_getNeuronsRef(self)

    def getWeightsMatrix(self) -> "GRT::Matrix< GRT::VectorFloat >":
        return _GRT.SelfOrganizingMap_getWeightsMatrix(self)

    def setNetworkSize(self, networkSize: 'UINT const') -> "bool":
        return _GRT.SelfOrganizingMap_setNetworkSize(self, networkSize)

    def setNetworkTypology(self, networkTypology: 'UINT const') -> "bool":
        return _GRT.SelfOrganizingMap_setNetworkTypology(self, networkTypology)

    def setAlphaStart(self, alphaStart: 'GRT::Float const') -> "bool":
        return _GRT.SelfOrganizingMap_setAlphaStart(self, alphaStart)

    def setAlphaEnd(self, alphaEnd: 'GRT::Float const') -> "bool":
        return _GRT.SelfOrganizingMap_setAlphaEnd(self, alphaEnd)

    def setSigmaWeight(self, sigmaWeight: 'GRT::Float const') -> "bool":
        return _GRT.SelfOrganizingMap_setSigmaWeight(self, sigmaWeight)

    def save(self, *args) -> "bool":
        return _GRT.SelfOrganizingMap_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.SelfOrganizingMap_load(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.SelfOrganizingMap_getId)
    else:
        getId = _GRT.SelfOrganizingMap_getId
SelfOrganizingMap_swigregister = _GRT.SelfOrganizingMap_swigregister
SelfOrganizingMap_swigregister(SelfOrganizingMap)

def SelfOrganizingMap_getId() -> "std::string":
    return _GRT.SelfOrganizingMap_getId()
SelfOrganizingMap_getId = _GRT.SelfOrganizingMap_getId

class FeatureExtraction(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FeatureExtraction, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FeatureExtraction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_FeatureExtraction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_FeatureExtraction
    __del__ = lambda self: None

    def deepCopyFrom(self, rhs: 'FeatureExtraction') -> "bool":
        return _GRT.FeatureExtraction_deepCopyFrom(self, rhs)

    def copyBaseVariables(self, featureExtractionModule: 'FeatureExtraction') -> "bool":
        return _GRT.FeatureExtraction_copyBaseVariables(self, featureExtractionModule)

    def predict(self, *args) -> "bool":
        return _GRT.FeatureExtraction_predict(self, *args)

    def computeFeatures(self, *args) -> "bool":
        return _GRT.FeatureExtraction_computeFeatures(self, *args)

    def clear(self) -> "bool":
        return _GRT.FeatureExtraction_clear(self)

    def getInitialized(self) -> "bool":
        return _GRT.FeatureExtraction_getInitialized(self)

    def getFeatureDataReady(self) -> "bool":
        return _GRT.FeatureExtraction_getFeatureDataReady(self)

    def getIsTrainable(self) -> "bool":
        return _GRT.FeatureExtraction_getIsTrainable(self)

    def getFeatureVector(self) -> "GRT::VectorFloat const &":
        return _GRT.FeatureExtraction_getFeatureVector(self)

    def getFeatureMatrix(self) -> "GRT::MatrixFloat const &":
        return _GRT.FeatureExtraction_getFeatureMatrix(self)

    def create(self, *args) -> "GRT::FeatureExtraction *":
        return _GRT.FeatureExtraction_create(self, *args)

    def save(self, *args) -> "bool":
        return _GRT.FeatureExtraction_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.FeatureExtraction_load(self, *args)

    def createNewInstance(self) -> "GRT::FeatureExtraction *":
        return _GRT.FeatureExtraction_createNewInstance(self)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.FeatureExtraction_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.FeatureExtraction_createInstanceFromString

    def getFeatureExtractionType(self) -> "std::string":
        return _GRT.FeatureExtraction_getFeatureExtractionType(self)
FeatureExtraction_swigregister = _GRT.FeatureExtraction_swigregister
FeatureExtraction_swigregister(FeatureExtraction)

def FeatureExtraction_createInstanceFromString(id: 'std::string const &') -> "GRT::FeatureExtraction *":
    return _GRT.FeatureExtraction_createInstanceFromString(id)
FeatureExtraction_createInstanceFromString = _GRT.FeatureExtraction_createInstanceFromString

class KMeansQuantizer(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KMeansQuantizer, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KMeansQuantizer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_KMeansQuantizer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_KMeansQuantizer
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.KMeansQuantizer_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.KMeansQuantizer_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.KMeansQuantizer_reset(self)

    def clear(self) -> "bool":
        return _GRT.KMeansQuantizer_clear(self)

    def quantize(self, *args) -> "UINT":
        return _GRT.KMeansQuantizer_quantize(self, *args)

    def getQuantizerTrained(self) -> "bool":
        return _GRT.KMeansQuantizer_getQuantizerTrained(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.KMeansQuantizer_getNumClusters(self)

    def getQuantizedValue(self) -> "UINT":
        return _GRT.KMeansQuantizer_getQuantizedValue(self)

    def getQuantizationDistances(self) -> "GRT::VectorFloat":
        return _GRT.KMeansQuantizer_getQuantizationDistances(self)

    def getQuantizationModel(self) -> "GRT::MatrixFloat":
        return _GRT.KMeansQuantizer_getQuantizationModel(self)

    def setNumClusters(self, numClusters: 'UINT const') -> "bool":
        return _GRT.KMeansQuantizer_setNumClusters(self, numClusters)

    def save(self, *args) -> "bool":
        return _GRT.KMeansQuantizer_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.KMeansQuantizer_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.KMeansQuantizer_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.KMeansQuantizer_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.KMeansQuantizer_getId)
    else:
        getId = _GRT.KMeansQuantizer_getId
KMeansQuantizer_swigregister = _GRT.KMeansQuantizer_swigregister
KMeansQuantizer_swigregister(KMeansQuantizer)

def KMeansQuantizer_getId() -> "std::string":
    return _GRT.KMeansQuantizer_getId()
KMeansQuantizer_getId = _GRT.KMeansQuantizer_getId

class LinearRegression(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearRegression, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinearRegression, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_LinearRegression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_LinearRegression
    __del__ = lambda self: None

    def deepCopyFrom(self, regressifier: 'Regressifier const *') -> "bool":
        return _GRT.LinearRegression_deepCopyFrom(self, regressifier)

    def train_(self, trainingData: 'GRT::RegressionData &') -> "bool":
        return _GRT.LinearRegression_train_(self, trainingData)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.LinearRegression_predict_(self, inputVector)

    def getMaxNumIterations(self) -> "UINT":
        return _GRT.LinearRegression_getMaxNumIterations(self)

    def setMaxNumIterations(self, maxNumIterations: 'UINT const') -> "bool":
        return _GRT.LinearRegression_setMaxNumIterations(self, maxNumIterations)
    if _newclass:
        getId = staticmethod(_GRT.LinearRegression_getId)
    else:
        getId = _GRT.LinearRegression_getId

    def save(self, *args) -> "bool":
        return _GRT.LinearRegression_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.LinearRegression_load(self, *args)
LinearRegression_swigregister = _GRT.LinearRegression_swigregister
LinearRegression_swigregister(LinearRegression)

def LinearRegression_getId() -> "std::string":
    return _GRT.LinearRegression_getId()
LinearRegression_getId = _GRT.LinearRegression_getId

# This file is compatible with both classic and new-style classes.


